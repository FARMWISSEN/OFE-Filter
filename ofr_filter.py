# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OFRFilter
                                 A QGIS plugin
 Filtering Point Data for On-Farm Experiments
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-09-03
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Sebastian Ramm
        email                : sebastian.ramm@fh-kiel.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QDate
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QPushButton, QDialog, QVBoxLayout, QLabel, QInputDialog, QLineEdit
from qgis.core import (
    QgsProject, QgsVectorLayer, QgsWkbTypes, QgsVectorFileWriter, QgsSpatialIndex, 
    QgsCoordinateTransform, QgsFeature, QgsRectangle, QgsFeatureRequest, 
    QgsSymbol, QgsGraduatedSymbolRenderer, QgsRendererRange
)
from qgis.utils import iface
from PyQt5.QtGui import QColor
from PyQt5.QtCore import QVariant

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ofr_filter_dialog import OFRFilterDialog
import os.path
import pandas as pd
import numpy as np
from .ofr_LogManager import LogManager as log

class OFRFilter:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Information for Logging
        self.plugin_name = "OFR_Filter"
        self.plugin_version = "0.0.2"

        # Save reference to the QGIS interface
        self.iface = iface
        
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OFRFilter_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Praxisversuche')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.punktauswahl_gesamt =  []

    # noinspection PyMethodMayBeStatic

    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('OFRFilter', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = f'{self.plugin_dir}/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'OFR Filter für Punktdaten'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&OFR Filter'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""
        # Überprüfen, ob das QGIS-Projekt gespeichert ist
        project_path = QgsProject.instance().fileName()
        if not project_path:
            QMessageBox.critical(None, "Fehler", "Das QGIS-Projekt muss gespeichert werden, bevor das Plugin verwendet werden kann.")
            return
 
        # Ermitteln des Projektverzeichnisses
        project_dir = os.path.dirname(project_path)

        # Pfad zum neuen Ordner "OFR_Filter"
        self.ofr_filter_dir = os.path.join(project_dir, "OFR_Filter")

        # Überprüfen, ob der Ordner bereits existiert, und falls nicht, erstellen
        if not os.path.exists(self.ofr_filter_dir):
            os.makedirs(self.ofr_filter_dir)
       
        # Erstellen und Anzeigen des Dialogs
        if self.first_start:
            #self.first_start = False
            self.dlg = OFRFilterDialog(self.ofr_filter_dir, self)
           
        # Zuschnitt-Karte initialisieren
        self.dlg.initialize_map_zuschnitt()
        
        self.dlg.show()       
        
        result = self.dlg.exec_()

    ###################
    ### Daten laden ###
    ###################
    def add_filtered_layer(self, original_layer, ofr_filter_dir):
        """Erstellt einen neuen Layer und bietet an, ein Präfix hinzuzufügen, falls ein Layer mit demselben Namen bereits existiert."""
        
        new_layer_name = "Filter_" + original_layer.name()
        new_layer_path = os.path.join(ofr_filter_dir, new_layer_name + ".shp")

        # 1. Prüfen, ob der Layer bereits im Projekt existiert
        existing_layers = QgsProject.instance().mapLayersByName(new_layer_name)
        if existing_layers:
            reply, ok = QInputDialog.getText(None, "Präfix erforderlich",
                                             f"Es befindet sich bereits ein Layer mit dem Namen {new_layer_name} im Projekt. "
                                             "Geben Sie ein Präfix ein oder brechen Sie den Vorgang ab:",
                                             QLineEdit.Normal, "")
            if not ok or not reply:
                QMessageBox.information(None, "Abgebrochen", "Der Vorgang wurde abgebrochen.")
                self.dlg.fertig = 1
                self.dlg.close()
                return
            else:
                # Benutzer hat ein Präfix eingegeben, neuen Layernamen anpassen
                new_layer_name = reply + "_" + new_layer_name
                new_layer_path = os.path.join(ofr_filter_dir, new_layer_name + ".shp")
                self.dlg.mMapLayerComboBox_Daten.setEnabled(False)
        
        # 2. Prüfen, ob eine Datei mit dem gleichen Namen bereits im Dateisystem existiert
        if os.path.exists(new_layer_path):
            reply = QMessageBox.question(None, "Datei existiert bereits",
                                         f"Die Datei {new_layer_name}.shp existiert bereits. Möchten Sie sie überschreiben?",
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.No:
                QMessageBox.information(None, "Abgebrochen", "Der Vorgang wurde abgebrochen.")
                self.dlg.mMapLayerComboBox_Daten.setEnabled(True)
                return
            else:
                # Löschen der bestehenden Shapefile-Datei und ihrer Komponenten
                for ext in ['.shp', '.shx', '.dbf', '.prj', '.cpg']:
                    file_path = os.path.splitext(new_layer_path)[0] + ext
                    if os.path.exists(file_path):
                        os.remove(file_path)
                self.dlg.mMapLayerComboBox_Daten.setEnabled(False)

        # 3. Layer speichern und hinzufügen, wenn keine Konflikte bestehen
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = "ESRI Shapefile"
        options.fileEncoding = "UTF-8"

        result = QgsVectorFileWriter.writeAsVectorFormatV3(
            layer=original_layer,
            fileName=new_layer_path,
            transformContext=QgsProject.instance().transformContext(),
            options=options
        )

        # Überprüfen des Fehlercodes (erstes Element des Tupels)
        if result[0] != QgsVectorFileWriter.NoError:
            QMessageBox.critical(None, "Fehler", f"Der neue Layer konnte nicht gespeichert werden. Fehlercode: {result[0]}")
            return

        # Hinzufügen des neuen Layers zur Karte
        new_layer = QgsVectorLayer(new_layer_path, new_layer_name, "ogr")
        if not new_layer.isValid():
            QMessageBox.critical(None, "Fehler", "Der gespeicherte Layer konnte nicht geladen werden.")
            return
        
        # Erstellen oder Finden der Layergruppe
        group_name = "Gefilterte Daten"
        root = QgsProject.instance().layerTreeRoot()
        layer_group = root.findGroup(group_name)

        if layer_group is None:
            layer_group = root.addGroup(group_name)

        # Hinzufügen des neuen Layers zur Gruppe
        QgsProject.instance().addMapLayer(new_layer, False)
        layer_group.addLayer(new_layer)
        
        # Speichern des new_layer als Instanzvariable für spätere Verwendung
        self.dlg.new_layer = new_layer
        
        # Kopie vom neuen Layer behalten als Instanzvariable für spätere Verwendung
        self.dlg.copy_new_layer = new_layer
        
        # Hinzufügen-Button deaktivieren
        self.dlg.pushButton.setEnabled(False)
        
        # Spaltenauswahl aktivieren
        self.dlg.populate_column_combobox(new_layer)
        self.dlg.columnComboBox.setEnabled(True)
        
        # Erstelle die Karte
        self.dlg.fill_map_widget_zuschneiden()
        
    def apply_graduated_style(self, new_layer, column):
        """Weist dem Vector-Punkt-Layer 'new_layer' eine abgestufte Symbolisierung zu und setzt die Symbolgröße auf 1."""
        
        if self.dlg.columnComboBox.currentIndex() > 0:
            # Anzahl der Klassen
            num_classes = 8
            
            # Manuelle Definition eines Farbverlaufs (Rot zu Grün)
            colors = [QColor(255, 0, 0), QColor(255, 165, 0), QColor(255, 255, 0), QColor(173, 255, 47), 
                      QColor(0, 255, 0), QColor(50, 205, 50), QColor(34, 139, 34), QColor(0, 128, 0)]
            
            # Berechne den minimalen und maximalen Wert der Spalte
            field_index = new_layer.fields().indexFromName(column)
            min_value = new_layer.minimumValue(field_index)
            max_value = new_layer.maximumValue(field_index)

            if min_value is None or max_value is None or max_value == min_value:
                return

            # Erstelle eine Liste von QgsRendererRange Objekten
            range_list = []
            for i in range(num_classes):
                lower_bound = min_value + (i * (max_value - min_value) / num_classes)
                upper_bound = min_value + ((i + 1) * (max_value - min_value) / num_classes)
                
                # Erstelle ein Symbol für jede Klasse
                symbol = QgsSymbol.defaultSymbol(new_layer.geometryType())
                
                # Setze die Farbe für jede Klasse basierend auf dem manuellen Farbverlauf
                symbol.setColor(colors[i])
                
                # Setze die Symbolgröße auf 1
                symbol.setSize(1)
                
                # Definiere den Bereich und füge ihn der Liste hinzu
                range_label = f"{lower_bound:.2f} - {upper_bound:.2f}"
                range_item = QgsRendererRange(lower_bound, upper_bound, symbol, range_label)
                range_list.append(range_item)

            # Erstelle den Graduated Renderer
            renderer = QgsGraduatedSymbolRenderer(column, range_list)
            
            # Wende den Renderer auf den Layer an
            new_layer.setRenderer(renderer)
            new_layer.triggerRepaint()
        else:
            return

    #########################
    ### Daten zuschneiden ###
    #########################
    def lösche_punkte_ausserhalb_feldgrenze(self, new_layer, feldgrenze_layer):
        """Löscht alle Punkte im new_layer, die sich außerhalb des feldgrenze_layer Polygons befinden."""
        # Erstellen eines temporären Layers mit transformierter Geometrie
        temp_feldgrenze = QgsVectorLayer("Polygon?crs={}".format(new_layer.crs().authid()), 
                                          "temp_feldgrenze", 
                                          "memory")
        temp_feldgrenze_data = temp_feldgrenze.dataProvider()
        
        # Transformieren der Geometrie des feldgrenze_layer in die Projektion des new_layer
        transform_context = QgsProject.instance().transformContext()
        coord_transform = QgsCoordinateTransform(feldgrenze_layer.crs(), new_layer.crs(), transform_context)
        
        for polygon_feature in feldgrenze_layer.getFeatures():
            polygon_geom = polygon_feature.geometry()
            polygon_geom.transform(coord_transform)
            new_feature = QgsFeature()
            new_feature.setGeometry(polygon_geom)
            temp_feldgrenze_data.addFeature(new_feature)
        
        temp_feldgrenze.updateExtents()

        # Starten der Editiersitzung
        new_layer.startEditing()

        # Erstellen eines räumlichen Indexes für die Suche nach Features im temporären Polygon-Layer
        index = QgsSpatialIndex(temp_feldgrenze.getFeatures())

        # Liste zum Speichern der IDs der zu löschenden Features
        ids_to_delete = []

        # Gesamtanzahl der Punkte im Layer
        total_points = new_layer.featureCount()

        # Iteriere über alle Features im Layer und selektiere diejenigen, die außerhalb der Polygone liegen
        for point_feature in new_layer.getFeatures():
            point_geom = point_feature.geometry()
            
            # Suche im Index nach allen Polygonen, deren BoundingBox den Punkt schneidet
            ids = index.intersects(point_geom.boundingBox())
            
            # Überprüfen, ob der Punkt innerhalb eines Polygons liegt
            keep_point = False
            for id in ids:
                temp_polygon_feature = temp_feldgrenze.getFeature(id)
                temp_polygon_geom = temp_polygon_feature.geometry()
                
                # Wenn das Polygon den Punkt enthält, markieren wir ihn zum Behalten
                if temp_polygon_geom.contains(point_geom):
                    keep_point = True
                    break
            
            # Wenn der Punkt nicht innerhalb eines Polygons liegt, markiere ihn zum Löschen
            if not keep_point:
                ids_to_delete.append(point_feature.id())

        # Überprüfe, ob alle Punkte selektiert wurden (d.h. alle Punkte sollen gelöscht werden)
        if len(ids_to_delete) == total_points:
            QMessageBox.warning(None, "Fehler", "Operation nicht zulässig, Sie sind im Begriff alle Punkte zu löschen.")
            new_layer.rollBack()  # Bricht die Editiersitzung ab
            return
    
        # Wenn nicht alle Punkte ausgewählt wurden, lösche die selektierten Punkte
        new_layer.deleteFeatures(ids_to_delete)

        # Änderungen speichern und Editiersitzung beenden
        new_layer.commitChanges()

        deleted_count = len(ids_to_delete)

        # Rückmeldung über gelöschte Punkte
        QMessageBox.information(None, "Auf Feldgrenze zuschneiden", f"{deleted_count} Punkte wurden gelöscht.")

        self.dlg.log.log_event("Zuschnitt",{"Fläche":"Feldgrenze", "Entfernte Punkte:":f"{deleted_count}"})
        
        # Symbolisierung des Layers updaten
        if deleted_count is not None:
            self.dlg.on_SymbButton_clicked()
            
        # Karte aktualisieren
        self.dlg.update_map_zuschneiden_new_layer()
        
    def lösche_punkte_auf_Vorgewende(self, new_layer, innenflaeche_layer):
        """Löscht alle Punkte im new_layer, die sich außerhalb des innenflaeche_layer Polygons befinden."""
        # Erstellen eines temporären Layers mit transformierter Geometrie
        temp_innenflaeche = QgsVectorLayer("Polygon?crs={}".format(new_layer.crs().authid()), 
                                          "temp_innenflaeche", 
                                          "memory")
        temp_innenflaeche_data = temp_innenflaeche.dataProvider()
        
        # Transformieren der Geometrie des innenflaeche_layer in die Projektion des new_layer
        transform_context = QgsProject.instance().transformContext()
        coord_transform = QgsCoordinateTransform(innenflaeche_layer.crs(), new_layer.crs(), transform_context)
        
        for polygon_feature in innenflaeche_layer.getFeatures():
            polygon_geom = polygon_feature.geometry()
            polygon_geom.transform(coord_transform)
            new_feature = QgsFeature()
            new_feature.setGeometry(polygon_geom)
            temp_innenflaeche_data.addFeature(new_feature)
        
        temp_innenflaeche.updateExtents()

        new_layer.startEditing()

        # Erstellen eines räumlichen Indexes für die Polygone im temporären Innenflächen-Layer
        index = QgsSpatialIndex(temp_innenflaeche.getFeatures())

        # Liste zum Speichern der IDs der zu löschenden Punkte
        ids_to_delete = []

        # Gesamtanzahl der Punkte im Layer
        total_points = new_layer.featureCount()

        # Iteriere über alle Features im new_layer
        for point_feature in new_layer.getFeatures():
            point_geom = point_feature.geometry()
            
            # Suche im Index nach allen Polygonen, deren BoundingBox den Punkt schneidet
            ids = index.intersects(point_geom.boundingBox())
            
            # Überprüfen, ob der Punkt innerhalb eines Polygons liegt
            keep_point = False
            for id in ids:
                temp_polygon_feature = temp_innenflaeche.getFeature(id)
                temp_polygon_geom = temp_polygon_feature.geometry()
                
                # Wenn das Polygon den Punkt enthält, behalten wir den Punkt
                if temp_polygon_geom.contains(point_geom):
                    keep_point = True
                    break
            
            # Wenn der Punkt nicht innerhalb eines Polygons liegt, markiere ihn zum Löschen
            if not keep_point:
                ids_to_delete.append(point_feature.id())

        # Überprüfe, ob alle Punkte selektiert wurden (d.h. alle Punkte sollen gelöscht werden)
        if len(ids_to_delete) == total_points:
            QMessageBox.warning(None, "Fehler", "Operation nicht zulässig, Sie sind im Begriff alle Punkte zu löschen.")
            new_layer.rollBack()  # Bricht die Editiersitzung ab
            return

        # Wenn nicht alle Punkte ausgewählt wurden, lösche die selektierten Punkte
        new_layer.deleteFeatures(ids_to_delete)

        # Änderungen speichern und Editiersitzung beenden
        new_layer.commitChanges()

        deleted_count = len(ids_to_delete)

        # Rückmeldung über gelöschte Punkte
        QMessageBox.information(None, "Vorgewende abschneiden", f"{deleted_count} Punkte wurden gelöscht.")

        self.dlg.log.log_event("Zuschnitt",{"Fläche":"Innenfläche", "Entfernte Punkte:":f"{deleted_count}"})
        
        # Symbolisierung des Layers updaten
        if deleted_count is not None:
            self.dlg.on_SymbButton_clicked()
            
        # Karte aktualisieren
        self.dlg.update_map_zuschneiden_new_layer()
        
    def lösche_punkte_außerhalb_Parzellen(self, new_layer, parzellen_layer):
        """Löscht alle Punkte im new_layer, die sich außerhalb der Parzellen befinden."""
        # Erstellen eines temporären Layers mit transformierter Geometrie
        temp_parzelle = QgsVectorLayer("Polygon?crs={}".format(new_layer.crs().authid()), 
                                       "temp_parzelle", 
                                       "memory")
        temp_parzelle_data = temp_parzelle.dataProvider()
        
        # Transformieren der Geometrie des parzellen_layer in die Projektion des new_layer
        transform_context = QgsProject.instance().transformContext()
        coord_transform = QgsCoordinateTransform(parzellen_layer.crs(), new_layer.crs(), transform_context)
        
        for polygon_feature in parzellen_layer.getFeatures():
            polygon_geom = polygon_feature.geometry()
            polygon_geom.transform(coord_transform)
            new_feature = QgsFeature()
            new_feature.setGeometry(polygon_geom)
            temp_parzelle_data.addFeature(new_feature)
        
        temp_parzelle.updateExtents()

        # Starten der Editiersitzung
        new_layer.startEditing()

        # Erstellen eines räumlichen Indexes für die Polygone im temporären Parzellen-Layer
        index = QgsSpatialIndex(temp_parzelle.getFeatures())

        # Liste zum Speichern der IDs der zu löschenden Punkte
        ids_to_delete = []

        # Gesamtanzahl der Punkte im Layer
        total_points = new_layer.featureCount()

        # Iteriere über alle Features im new_layer
        for point_feature in new_layer.getFeatures():
            point_geom = point_feature.geometry()
            
            # Suche im Index nach allen Polygonen, deren BoundingBox den Punkt schneidet
            ids = index.intersects(point_geom.boundingBox())
            
            # Überprüfen, ob der Punkt innerhalb eines Polygons liegt
            keep_point = False
            for id in ids:
                temp_polygon_feature = temp_parzelle.getFeature(id)
                temp_polygon_geom = temp_polygon_feature.geometry()
                
                # Wenn das Polygon den Punkt enthält, behalten wir den Punkt
                if temp_polygon_geom.contains(point_geom):
                    keep_point = True
                    break
            
            # Wenn der Punkt nicht innerhalb eines Polygons liegt, markiere ihn zum Löschen
            if not keep_point:
                ids_to_delete.append(point_feature.id())

        # Überprüfe, ob alle Punkte selektiert wurden (d.h. alle Punkte sollen gelöscht werden)
        if len(ids_to_delete) == total_points:
            QMessageBox.warning(None, "Fehler", "Operation nicht zulässig, Sie sind im Begriff alle Punkte zu löschen.")
            new_layer.rollBack()  # Bricht die Editiersitzung ab
            return

        # Wenn nicht alle Punkte ausgewählt wurden, lösche die selektierten Punkte
        new_layer.deleteFeatures(ids_to_delete)

        # Änderungen speichern und Editiersitzung beenden
        new_layer.commitChanges()

        deleted_count = len(ids_to_delete)

        # Rückmeldung über gelöschte Punkte
        QMessageBox.information(None, "Löschen von Punkten außerhalb der Parzellen", f"{deleted_count} Punkte wurden gelöscht.")

        self.dlg.log.log_event("Zuschnitt",{"Fläche":"Parzelle", "Entfernte Punkte:":f"{deleted_count}"})
        
        # Symbolisierung des Layers updaten
        if deleted_count is not None:
            self.dlg.on_SymbButton_clicked()
            
        # Karte aktualisieren
        self.dlg.update_map_zuschneiden_new_layer()
        
    def lösche_punkte_in_af(self, new_layer, af_layer):
        """Löscht alle Punkte im new_layer, die sich innerhalb der Ausschlussfläche befinden."""
        # Erstellen eines temporären Layers mit transformierter Geometrie
        temp_af = QgsVectorLayer("Polygon?crs={}".format(new_layer.crs().authid()), 
                                 "temp_af", 
                                 "memory")
        temp_af_data = temp_af.dataProvider()
        
        # Transformieren der Geometrie des af_layer in die Projektion des new_layer
        transform_context = QgsProject.instance().transformContext()
        coord_transform = QgsCoordinateTransform(af_layer.crs(), new_layer.crs(), transform_context)
        
        for polygon_feature in af_layer.getFeatures():
            polygon_geom = polygon_feature.geometry()
            polygon_geom.transform(coord_transform)
            new_feature = QgsFeature()
            new_feature.setGeometry(polygon_geom)
            temp_af_data.addFeature(new_feature)
        
        temp_af.updateExtents()

        # Starten der Editiersitzung
        new_layer.startEditing()

        # Erstellen eines räumlichen Indexes für die Polygone im AF-Layer
        index = QgsSpatialIndex(temp_af.getFeatures())

        # Liste zum Speichern der IDs der zu löschenden Punkte
        ids_to_delete = []

        # Gesamtanzahl der Punkte im Layer
        total_points = new_layer.featureCount()

        # Iteriere über alle Features im new_layer
        for point_feature in new_layer.getFeatures():
            point_geom = point_feature.geometry()
            
            # Suche im Index nach allen Polygonen, deren BoundingBox den Punkt schneidet
            ids = index.intersects(point_geom.boundingBox())
            
            # Überprüfen, ob der Punkt innerhalb eines Polygons liegt
            delete_point = False
            for id in ids:
                temp_polygon_feature = temp_af.getFeature(id)
                temp_polygon_geom = temp_polygon_feature.geometry()
                
                # Wenn das Polygon den Punkt enthält, wird der Punkt markiert zum Löschen
                if temp_polygon_geom.contains(point_geom):
                    delete_point = True
                    break
            
            # Wenn der Punkt innerhalb eines Polygons liegt, markiere ihn zum Löschen
            if delete_point:
                ids_to_delete.append(point_feature.id())

        # Überprüfe, ob alle Punkte selektiert wurden (d.h. alle Punkte sollen gelöscht werden)
        if len(ids_to_delete) == total_points:
            QMessageBox.warning(None, "Fehler", "Operation nicht zulässig, Sie sind im Begriff alle Punkte zu löschen.")
            new_layer.rollBack()  # Bricht die Editiersitzung ab
            return

        # Wenn nicht alle Punkte ausgewählt wurden, lösche die selektierten Punkte
        new_layer.deleteFeatures(ids_to_delete)

        # Änderungen speichern und Editiersitzung beenden
        new_layer.commitChanges()

        deleted_count = len(ids_to_delete)

        # Rückmeldung über gelöschte Punkte
        QMessageBox.information(None, "Löschen von Punkten in der Ausschlussfläche", f"{deleted_count} Punkte wurden gelöscht.")
        
        self.dlg.log.log_event("Zuschnitt",{"Fläche":"Ausschlussfläche", "Entfernte Punkte:":f"{deleted_count}"})
        
        # Symbolisierung des Layers updaten
        if deleted_count is not None:
            self.dlg.on_SymbButton_clicked()
            
        # Karte aktualisieren
        self.dlg.update_map_zuschneiden_new_layer()


    def polygon_selection(self, new_layer):
        """Aktiviert das eingebaute Werkzeug 'Objekte über Polygon wählen' und zeigt ein nicht-modales Dialogfenster zur Bestätigung an."""

        # Den Layer "new_layer" aktivieren/auswählen
        iface.setActiveLayer(new_layer)

        # Werkzeug "Objekte über Polygon auswählen" aktivieren
        iface.actionSelectPolygon().trigger()

        # Nicht-modales Dialogfenster zur Bestätigung anzeigen
        dialog = QDialog()
        dialog.setWindowTitle("Auswahl bestätigen")

        layout = QVBoxLayout()

        label = QLabel("Zeichnen Sie mehrere Polygone, um Punkte auszuwählen. Klicken Sie auf 'Auswahl beenden', wenn Sie fertig sind.")
        layout.addWidget(label)

        confirm_button = QPushButton("Auswahl beenden")
        confirm_button.clicked.connect(lambda: self.polygon_confirm_selection(dialog, new_layer))
        layout.addWidget(confirm_button)

        dialog.setLayout(layout)

        # Setze das Dialogfenster permanent in den Vordergrund
        dialog.setWindowFlag(Qt.WindowStaysOnTopHint)

        dialog.setModal(False)  # Setze den Dialog als nicht-modal
        dialog.show()

        # Speichern der IDs der aktuell ausgewählten Features
        self.existing_selection = set(new_layer.selectedFeatureIds())

        # Hinzufügen einer Schaltfläche zum Hinzufügen zur Auswahl
        add_to_selection_button = QPushButton("Zur Auswahl hinzufügen")
        add_to_selection_button.clicked.connect(lambda: self.add_to_selection(new_layer))
        layout.addWidget(add_to_selection_button)

    def add_to_selection(self, new_layer):
        """Fügt die aktuell ausgewählten Punkte zur bestehenden Auswahl hinzu."""
        # IDs der aktuell ausgewählten Features abrufen
        current_selection = set(new_layer.selectedFeatureIds())
        
        # Zur bestehenden Auswahl hinzufügen
        self.existing_selection.update(current_selection)
        
        # Auswahl im Layer aktualisieren
        new_layer.selectByIds(list(self.existing_selection))

    def polygon_confirm_selection(self, dialog, new_layer):
        """Bestätigt die Auswahl, zeigt die Anzahl der ausgewählten Punkte an und fragt, ob die Punkte gelöscht werden sollen."""
        selected_features = new_layer.selectedFeatures()

        if selected_features:
            count = len(selected_features)
            total_points = new_layer.featureCount()  # Gesamtanzahl der Punkte im Layer

            # Überprüfe, ob alle Punkte ausgewählt wurden
            if count == total_points:
                QMessageBox.warning(None, "Fehler", "Operation nicht zulässig, Sie sind im Begriff, alle Punkte zu löschen.")
                dialog.reject()  # Schließt den Dialog, ohne die Auswahl zu löschen
                self.dlg.showNormal() # Zeigen Sie das Plugin-Fenster wieder normal an
                new_layer.removeSelection()
                return

            # Bestätigungsdialog für das Löschen der ausgewählten Punkte
            reply = QMessageBox.question(None, "Punkte löschen?",
                                         f"{count} Punkte wurden ausgewählt. Möchten Sie diese Punkte jetzt löschen?",
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

            if reply == QMessageBox.Yes:
                # Punkte löschen
                new_layer.startEditing()
                for feature in selected_features:
                    new_layer.deleteFeature(feature.id())
                new_layer.commitChanges()

                QMessageBox.information(None, "Löschung", f"{count} Punkte wurden gelöscht.")
                self.dlg.log.log_event("Manueller Zuschnitt", {"Entfernte Punkte":f"{count}"})
            else:
                # Auswahl aufheben
                new_layer.removeSelection()
        else:
            QMessageBox.warning(None, "Auswahl", "Keine Punkte wurden ausgewählt.")

        dialog.accept()
        
        # Symbolisierung des Layers updaten
        self.dlg.on_SymbButton_clicked()
        
        # Zeigen Sie das Plugin-Fenster wieder normal an
        self.dlg.showNormal()

        # Setze das Standard-Werkzeug zurück
        iface.actionPan().trigger()  # Setzt das Werkzeug zurück auf das Verschieben-Werkzeug
        
        # Karte aktualisieren
        self.dlg.update_map_zuschneiden_new_layer()

    #####################    
    ### Daten Filtern ###
    #####################
    
    def create_auswahl_tabelle(self, layer):
        """ Erstellen der Auswahltabelle"""
        # Definiere die erste Spalte mit den Filtermethoden
        filter_methods = ["Untergrenze", "Obergrenze", "Standardabweichung"]
        
        # Erstelle eine Liste für die numerischen Spaltennamen
        numeric_columns = []
        
        # Hole die Felder des Layers
        fields = layer.fields()

        # Füge nur numerische Felder in die Liste ein
        for field in fields:
            if field.type() in (QVariant.Int, QVariant.Double, QVariant.LongLong, QVariant.UInt, QVariant.ULongLong):
                numeric_columns.append(field.name())

        # Erstelle eine leere Tabelle mit den entsprechenden Spalten
        # Die erste Spalte heißt 'Filtermethode', die anderen sind numerische Spalten
        columns = ['Filtermethode'] + numeric_columns

        # Initialisiere die Daten mit den Filtermethoden und numerischen Spalten (alle Werte in numerischen Spalten auf None gesetzt)
        data = [[method] + [None] * len(numeric_columns) for method in filter_methods]

        # Erstelle die Pandas-Tabelle (DataFrame)
        self.auswahl_tabelle = pd.DataFrame(data, columns=columns)

        return self.auswahl_tabelle
    
    def create_filterparameter_tabelle(self, new_layer):
        """ Erstellt die filterparameter_tabelle """
         # Definiere die erste Spalte mit den Filtermethoden
        filter_methods = [
            "Untergrenze",
            "Untergrenze Methode (0=kleiner/1=kleiner-gleich)",
            "Obergrenze",
            "Obergrenze Methode (0=groeßer/1=groeßer-gleich)",
            "Standardabweichung Multiplikator", 
            "Standardabweichung Methode (0=Ober- und Untergrenze/1=Untergrenze/2=Obergrenze)"
            "Standardabweichung Basis (0=Rohdaten/1=gefilterte Daten)"
        ]
        
        # Erstelle eine Liste für die numerischen Spaltennamen
        numeric_columns = []
        
        # Hole die Felder des Layers
        fields = new_layer.fields()

        # Füge nur numerische Felder in die Liste ein
        for field in fields:
            if field.type() in (QVariant.Int, QVariant.Double, QVariant.LongLong, QVariant.UInt, QVariant.ULongLong):
                numeric_columns.append(field.name())

        # Erstelle eine leere Tabelle mit den entsprechenden Spalten
        # Die erste Spalte heißt 'Filtermethode', die anderen sind numerische Spalten
        columns = ['Filtermethode'] + numeric_columns

        # Initialisiere die Daten mit den Filtermethoden und numerischen Spalten (alle Werte in numerischen Spalten auf None gesetzt)
        data = [[method] + [None] * len(numeric_columns) for method in filter_methods]

        # Erstelle die Pandas-Tabelle (DataFrame) und speichere sie als Instanzvariable
        self.filterparameter_tabelle = pd.DataFrame(data, columns=columns)
        
        return self.filterparameter_tabelle
        
    def create_multiindex_punktauswahl(self, new_layer):
        """ Erstellt einen Pandas DataFrame mit einem MultiIndex für die Gruppen 'Untergrenze', 'Obergrenze' und 'Standardabweichung',
        wobei für jede Gruppe und jedes numerische Feature eine leere Liste gespeichert wird."""
        
        # Definiere die Gruppen
        groups = ["Untergrenze", "Obergrenze", "Standardabweichung"]
        
        # Erstelle eine Liste für die numerischen Feature-Namen
        numeric_columns = []
        
        # Hole die Felder des Layers
        fields = new_layer.fields()

        # Füge nur numerische Felder in die Liste ein
        for field in fields:
            if field.type() in (QVariant.Int, QVariant.Double, QVariant.LongLong, QVariant.UInt, QVariant.ULongLong):
                numeric_columns.append(field.name())
        
        # Erstelle den MultiIndex
        index = pd.MultiIndex.from_product([groups, numeric_columns], names=['Gruppe', 'Feature'])
        
        # Erstelle ein DataFrame mit leeren Listen für jede Gruppe/Feature-Kombination
        self.filter_punktauswahl = pd.DataFrame({'Werte': [[] for _ in range(len(index))]}, index=index)

    def combine_filter_punktauswahl(self, new_layer):
        """ Führt alle Listen aus dem MultiIndex DataFrame filter_punktauswahl zusammen,
        entfernt Duplikate und sortiert die finale Liste in aufsteigender Reihenfolge."""
        if hasattr(self, 'filter_punktauswahl') and self.filter_punktauswahl is not None:          
            # Liste zum Speichern der zusammengeführten Zeilenindizes
            punktauswahl_gesamt = []
            
            # Iteriere durch alle Einträge des DataFrame filter_punktauswahl
            for row in self.filter_punktauswahl['Werte']:
                # Überprüfe, ob die Liste nicht leer ist
                if isinstance(row, list) and len(row) > 0:
                    # Füge die Werte der aktuellen Liste zu punktauswahl_gesamt hinzu
                    punktauswahl_gesamt.extend(row)

            # Entferne Duplikate durch Umwandlung in eine Menge (set) und zurück zu einer Liste
            punktauswahl_gesamt = list(set(punktauswahl_gesamt))

            # Sortiere die Liste in aufsteigender Reihenfolge
            punktauswahl_gesamt.sort()

            # Speichern der resultierenden Liste als Instanzvariable
            self.punktauswahl_gesamt = punktauswahl_gesamt

            # Setze die Anzahl der Einträge in punktauswahl_gesamt als gesamtauswahl
            self.gesamtauswahl = len(punktauswahl_gesamt)
            
            # Überprüfen, ob punktauswahl_gesamt Einträge hat
            if self.gesamtauswahl > 0:
                self.dlg.label_auswahl.setText(f"Anzahl ausgewählter Punkte: {self.gesamtauswahl}")
                self.dlg.label_auswahl_rel.setText(f"Relativer Anteil ausgewählter Punkte: {round(self.gesamtauswahl / len(new_layer) * 100, 2)}%")
                new_layer.selectByIds(self.punktauswahl_gesamt)
            else:
                self.dlg.label_auswahl.setText("kein Filter angewand")
                self.dlg.label_auswahl_rel.setText("")
                new_layer.removeSelection()  # Setze die Selektion zurück, falls nichts ausgewählt ist
        else:
            self.punktauswahl_gesamt = None
            self.gesamtauswahl = 0
            new_layer.removeSelection()
            self.dlg.label_auswahl.setText("keine Filter angewand")
            self.dlg.label_auswahl.setText("")
        
    ###### Untergrenze ######
    def filterfunction_untergrenze(self, new_layer):
        """ Diese Funktion filtert die Attribute des Layers basierend auf der ausgewählten Spalte und der Untergrenze.
        Sie speichert die Zeilenindizes, auf die die Bedingungen zutreffen, in filter_punktauswahl in der Gruppe 'Untergrenze'."""
        
        # Hole den aktuell ausgewählten Spaltennamen aus columnComboBox2
        selected_column = self.dlg.columnComboBox2.currentText()

        # Hole den aktuellen Wert für die Untergrenze aus doubleSpinBox_LB
        untergrenze_wert = self.dlg.doubleSpinBox_LB.value()

        # Prüfe, ob Index 0 (kleiner als) oder Index 1 (kleiner-gleich) in comboBox_LB ausgewählt ist
        selected_comparison = self.dlg.comboBox_LB.currentIndex()

        # Liste zum Speichern der Zeilenindizes, die die Bedingung erfüllen
        zeilenindizes = []

        # Hole die Features (Zeilen) des Layers
        features = new_layer.getFeatures()

        # Hole die Spaltenindex basierend auf dem Spaltennamen
        field_index = new_layer.fields().indexOf(selected_column)

        # Durchlaufe alle Features (Zeilen) des Layers und prüfe die Bedingung
        for feature in features:
            value = feature[field_index]  # Hole den Wert der entsprechenden Spalte
            
            if selected_comparison == 0:  # Index 0: "kleiner als"
                if value < untergrenze_wert:
                    zeilenindizes.append(feature.id())  # Speichere den Zeilenindex
            elif selected_comparison == 1:  # Index 1: "kleiner-gleich"
                if value <= untergrenze_wert:
                    zeilenindizes.append(feature.id())  # Speichere den Zeilenindex

        # Speichere die Zeilenindizes in filter_punktauswahl in der Gruppe 'Untergrenze'
        self.filter_punktauswahl.at[('Untergrenze', selected_column), 'Werte'] = zeilenindizes
        
        # Zähle die Anzahl der ausgewählten Zeilen
        anzahl_ausgewaehlter_zeilen = len(zeilenindizes)

        # Speichere die Anzahl der ausgewählten Zeilen in auswahl_tabelle in der Zeile für 'Untergrenze'
        self.auswahl_tabelle.at[0, selected_column] = anzahl_ausgewaehlter_zeilen

    ###### Obergrenze ######
    def filterfunction_obergrenze(self, new_layer):
        """ Diese Funktion filtert die Attribute des Layers basierend auf der ausgewählten Spalte und der Obergrenze.
        Sie speichert die Zeilenindizes, auf die die Bedingungen zutreffen, in filter_punktauswahl in der Gruppe 'Obergrenze'."""
        
        # Hole den aktuell ausgewählten Spaltennamen aus columnComboBox2
        selected_column = self.dlg.columnComboBox2.currentText()

        # Hole den aktuellen Wert für die Untergrenze aus doubleSpinBox_UB
        obergrenze_wert = self.dlg.doubleSpinBox_UB.value()

        # Prüfe, ob Index 0 (kleiner als) oder Index 1 (kleiner-gleich) in comboBox_LB ausgewählt ist
        selected_comparison = self.dlg.comboBox_UB.currentIndex()

        # Liste zum Speichern der Zeilenindizes, die die Bedingung erfüllen
        zeilenindizes = []

        # Hole die Features (Zeilen) des Layers
        features = new_layer.getFeatures()

        # Hole die Spaltenindex basierend auf dem Spaltennamen
        field_index = new_layer.fields().indexOf(selected_column)

        # Durchlaufe alle Features (Zeilen) des Layers und prüfe die Bedingung
        for feature in features:
            value = feature[field_index]  # Hole den Wert der entsprechenden Spalte
            
            if selected_comparison == 0:  # Index 0: "größer als"
                if value > obergrenze_wert:
                    zeilenindizes.append(feature.id())  # Speichere den Zeilenindex
            elif selected_comparison == 1:  # Index 1: "größer-gleich"
                if value >= obergrenze_wert:
                    zeilenindizes.append(feature.id())  # Speichere den Zeilenindex

        # Speichere die Zeilenindizes in filter_punktauswahl in der Gruppe 'Obergrenze'
        self.filter_punktauswahl.at[('Obergrenze', selected_column), 'Werte'] = zeilenindizes
        
        # Zähle die Anzahl der ausgewählten Zeilen
        anzahl_ausgewaehlter_zeilen = len(zeilenindizes)

        # Speichere die Anzahl der ausgewählten Zeilen in auswahl_tabelle in der Zeile für 'Obergrenze'
        self.auswahl_tabelle.at[1, selected_column] = anzahl_ausgewaehlter_zeilen
        
    ###### Standardabweichung ######
    def filterfunction_sd(self, new_layer):
        """ Diese Funktion filtert die Attribute des Layers basierend auf der ausgewählten Spalte der Standardabweichung und des Multiplikators.
        Sie speichert die Zeilenindizes, auf die die Bedingungen zutreffen, in filter_punktauswahl in der Gruppe 'Standardabweichung'."""
        
        # Hole den aktuell ausgewählten Spaltennamen aus columnComboBox2
        selected_column = self.dlg.columnComboBox2.currentText()
        
        # Hole den aktuellen Wert für den Multiplikator
        multiplikator_wert = self.dlg.doubleSpinBox_SD.value()

        # Hole dir die Methode: 0 = Ober- und Untergrenze, 1 = Untergrenze, 2 = Obergrenze
        selected_method = self.dlg.comboBox_sd.currentIndex()
        
        # Liste zum Speichern der Zeilenindizes, die die Bedingung erfüllen
        zeilenindizes = []              
        
        # Checkbox-Status holen
        if self.dlg.checkBox_SD.isChecked() and self.punktauswahl_gesamt is not None:
               
            filter_punktauswahl_ohne_SD = self.filter_punktauswahl.loc[self.filter_punktauswahl.index.get_level_values('Gruppe') != 'Standardabweichung']
                                 
            # Liste zum Speichern der zusammengeführten Zeilenindizes
            punktauswahl_gesamt_ohne_SD = []
            
            # Iteriere durch alle Einträge des DataFrame filter_punktauswahl_ohne_SD
            for row in filter_punktauswahl_ohne_SD['Werte']:
                # Überprüfe, ob die Liste nicht leer ist
                if isinstance(row, list) and len(row) > 0:
                    # Füge die Werte der aktuellen Liste zu punktauswahl_gesamt_ohne_SD hinzu
                    punktauswahl_gesamt_ohne_SD.extend(row)

            # Entferne Duplikate durch Umwandlung in eine Menge (set) und zurück zu einer Liste
            punktauswahl_gesamt_ohne_SD = list(set(punktauswahl_gesamt_ohne_SD))

            # Sortiere die Liste in aufsteigender Reihenfolge
            punktauswahl_gesamt_ohne_SD.sort()
                                 
            alle_filter_punkte = punktauswahl_gesamt_ohne_SD               
            alle_filter_punkte_flat = list(itertools.chain.from_iterable(alle_filter_punkte)) if any(isinstance(i, list) for i in alle_filter_punkte) else alle_filter_punkte               
            alle_filter_punkte_set = set(alle_filter_punkte_flat)
            
            # Erstelle die gefilterten Daten
            filtered_values = []
            for feat in self.dlg.new_layer.getFeatures():
                feat_id = feat.id()
                if feat_id not in alle_filter_punkte_set and feat[selected_column] is not None and self.dlg.is_numeric(feat[selected_column]):
                    filtered_values.append(float(feat[selected_column])) 
             
            # Berechne die Standardabweichung
            SD = np.std(filtered_values)
            
            # Berechne den Mittelwert
            MEAN = np.mean(filtered_values)
            
            # Berechne Ober- und Untergrenze
            SD_og = MEAN + (multiplikator_wert * SD)
            SD_ug = MEAN - (multiplikator_wert * SD)
         
            # Liste zum Speichern der Zeilenindizes, die die Bedingung erfüllen
            zeilenindizes = []              
            
            # Hole die Features (Zeilen) des Layers
            features = new_layer.getFeatures()

            # Hole die Spaltenindex basierend auf dem Spaltennamen
            field_index = new_layer.fields().indexOf(selected_column)

            # Hole dir die Werte
            values = [float(feat[selected_column]) for feat in self.dlg.new_layer.getFeatures() if feat[selected_column] is not None and self.dlg.is_numeric(feat[selected_column])]
            
            # Hole die Features (Zeilen) des Layers
            features = new_layer.getFeatures()

            # Hole die Spaltenindex basierend auf dem Spaltennamen
            field_index = new_layer.fields().indexOf(selected_column)
            
            # Durchlaufe alle Features (Zeilen) des Layers und prüfe die Bedingung
            for feature in features:
                value = feature[field_index]  # Hole den Wert der entsprechenden Spalte
                
                if selected_method == 0:  # Index 0: "Ober- und Untergrenze"
                    if value > SD_og:
                        zeilenindizes.append(feature.id())  # Speichere den Zeilenindex
                    elif value < SD_ug:
                        zeilenindizes.append(feature.id())  # Speichere den Zeilenindex
                elif selected_method == 1:  # Index 1: "Untergrenze"
                    if value < SD_ug:
                        zeilenindizes.append(feature.id())  # Speichere den Zeilenindex
                elif selected_method == 2:  # Index 1: "Obergrenze"
                    if value > SD_og:
                        zeilenindizes.append(feature.id())  # Speichere den Zeilenindex

            # Speichere die Zeilenindizes in filter_punktauswahl in der Gruppe 'Standardabweichung'
            self.filter_punktauswahl.at[('Standardabweichung', selected_column), 'Werte'] = zeilenindizes
            
            # Zähle die Anzahl der ausgewählten Zeilen
            anzahl_ausgewaehlter_zeilen = len(zeilenindizes)

            # Speichere die Anzahl der ausgewählten Zeilen in auswahl_tabelle in der Zeile für 'Standardabweichung'
            self.auswahl_tabelle.at[2, selected_column] = anzahl_ausgewaehlter_zeilen
        else:
            # Hole die Features (Zeilen) des Layers
            features = new_layer.getFeatures()

            # Hole die Spaltenindex basierend auf dem Spaltennamen
            field_index = new_layer.fields().indexOf(selected_column)

            # Hole dir die Werte
            values = [float(feat[selected_column]) for feat in self.dlg.new_layer.getFeatures() if feat[selected_column] is not None and self.dlg.is_numeric(feat[selected_column])]
            
            # Berechne die Standardabweichung
            SD = np.std(values)
            
            # Berechne den Mittelwert
            MEAN = np.mean(values)
            
            # Berechne Ober- und Untergrenze
            SD_og = MEAN + (multiplikator_wert * SD)
            SD_ug = MEAN - (multiplikator_wert * SD)
         
            # Liste zum Speichern der Zeilenindizes, die die Bedingung erfüllen
            zeilenindizes = []              
            
            # Hole die Features (Zeilen) des Layers
            features = new_layer.getFeatures()

            # Hole die Spaltenindex basierend auf dem Spaltennamen
            field_index = new_layer.fields().indexOf(selected_column)
            
            # Durchlaufe alle Features (Zeilen) des Layers und prüfe die Bedingung
            for feature in features:
                value = feature[field_index]  # Hole den Wert der entsprechenden Spalte
                
                if selected_method == 0:  # Index 0: "Ober- und Untergrenze"
                    if value > SD_og:
                        zeilenindizes.append(feature.id())  # Speichere den Zeilenindex
                    elif value < SD_ug:
                        zeilenindizes.append(feature.id())  # Speichere den Zeilenindex
                elif selected_method == 1:  # Index 1: "Untergrenze"
                    if value < SD_ug:
                        zeilenindizes.append(feature.id())  # Speichere den Zeilenindex
                elif selected_method == 2:  # Index 1: "Obergrenze"
                    if value > SD_og:
                        zeilenindizes.append(feature.id())  # Speichere den Zeilenindex

            # Speichere die Zeilenindizes in filter_punktauswahl in der Gruppe 'Standardabweichung'
            self.filter_punktauswahl.at[('Standardabweichung', selected_column), 'Werte'] = zeilenindizes
            
            # Zähle die Anzahl der ausgewählten Zeilen
            anzahl_ausgewaehlter_zeilen = len(zeilenindizes)

            # Speichere die Anzahl der ausgewählten Zeilen in auswahl_tabelle in der Zeile für 'Standardabweichung'
            self.auswahl_tabelle.at[2, selected_column] = anzahl_ausgewaehlter_zeilen

    #########################
    ### Attribute anfügen ###
    #########################
    
    def attribute_anfügen(self, new_layer):
        # 1. Aktuell ausgewählter Polygon-Layer
        parzellen_layer = self.dlg.mMapLayerComboBox_Parzellen.currentLayer()

        if parzellen_layer is None or new_layer is None:
            QMessageBox.warning(self.dlg, "Fehler", "Layer fehlen.")
            return

        # 2. Ausgewählte Attributnamen aus der CheckableComboBox
        selected_fields = self.dlg.mComboBox_Plots.checkedItems()
        if not selected_fields:
            QMessageBox.warning(self.dlg, "Hinweis", "Bitte wähle mindestens ein Attribut aus.")
            return

        # 3. Bearbeitung starten
        if not new_layer.isEditable():
            new_layer.startEditing()

        # 4. Fehlende Felder im new_layer ergänzen
        existing_field_names = [f.name() for f in new_layer.fields()]
        new_fields = []

        for field_name in selected_fields:
            if field_name not in existing_field_names:
                field_def = parzellen_layer.fields().field(field_name)
                new_fields.append(field_def)

        if new_fields:
            new_layer.dataProvider().addAttributes(new_fields)
            new_layer.updateFields()

        # 5. Punkt-Feature-Dict vorbereiten + Spatial Index aufbauen
        point_feature_dict = {}
        spatial_index = QgsSpatialIndex()

        for feature in new_layer.getFeatures():
            fid = feature.id()
            point_feature_dict[fid] = feature
            spatial_index.insertFeature(feature)

        # 6. Feld-Index-Cache vorbereiten
        field_indexes = {
            field_name: new_layer.fields().indexFromName(field_name)
            for field_name in selected_fields
        }

        # 7. Durch jedes Polygon gehen
        for polygon_feature in parzellen_layer.getFeatures():
            poly_geom = polygon_feature.geometry()
            candidate_ids = spatial_index.intersects(poly_geom.boundingBox())

            for fid in candidate_ids:
                point_feature = point_feature_dict.get(fid)
                if point_feature is None:
                    continue

                point_geom = point_feature.geometry()

                if poly_geom.contains(point_geom):
                    point_id = point_feature.id()

                    for field_name in selected_fields:
                        value = polygon_feature[field_name]
                        field_index = field_indexes[field_name]
                        new_layer.changeAttributeValue(point_id, field_index, value)

        # 8. Änderungen speichern
        if not new_layer.commitChanges():
            QMessageBox.critical(self.dlg, "Fehler", "Änderungen konnten nicht gespeichert werden!")
        else:
            new_layer.updateExtents()
            new_layer.triggerRepaint()
            self.dlg.populate_attribut_combobox(new_layer)
            QMessageBox.information(self.dlg, 'Erfolg', 'Attribute erfolgreich übertragen.')                
  
    def point_selection(self, new_layer):
        """Aktiviert das eingebaute Werkzeug 'Objekte über Polygon wählen' und zeigt ein 
        nicht-modales Dialogfenster zur Bestätigung an."""

        # Den Layer "new_layer" aktivieren/auswählen
        iface.setActiveLayer(new_layer)

        # Werkzeug "Objekte über Polygon auswählen" aktivieren
        iface.actionSelectPolygon().trigger()

        # Nicht-modales Dialogfenster zur Bestätigung anzeigen
        dialog = QDialog()
        dialog.setWindowTitle("Auswahl bestätigen")

        layout = QVBoxLayout()

        label = QLabel("Zeichnen Sie mehrere Polygone, um Punkte auszuwählen. Klicken Sie " \
        "auf 'Auswahl beenden', wenn Sie fertig sind.")
        layout.addWidget(label)

        confirm_button = QPushButton("Auswahl beenden")
        confirm_button.clicked.connect(lambda: self.point_confirm_selection(dialog, new_layer))
        layout.addWidget(confirm_button)

        dialog.setLayout(layout)

        # Setze das Dialogfenster permanent in den Vordergrund
        dialog.setWindowFlag(Qt.WindowStaysOnTopHint)

        dialog.setModal(False)  # Setze den Dialog als nicht-modal
        dialog.show()

        # # Speichern der IDs der aktuell ausgewählten Features
        self.existing_selection = set(new_layer.selectedFeatureIds())

        # # Hinzufügen einer Schaltfläche zum Hinzufügen zur Auswahl
        add_to_selection_button = QPushButton("Zur Auswahl hinzufügen")
        add_to_selection_button.clicked.connect(lambda: self.add_to_selection(new_layer))
        layout.addWidget(add_to_selection_button)

    def point_confirm_selection(self, dialog, new_layer):
        """Bestätigt die Auswahl, zeigt die Anzahl der ausgewählten Punkte an und fragt, 
        für welches Attribute die Werte überschrieben/bearbeitet werden sollen."""

        selected_features = new_layer.selectedFeatures()

        if selected_features:
            count = len(selected_features)
            total_points = new_layer.featureCount()  # Gesamtanzahl der Punkte im Layer

            # Überprüfe, ob alle Punkte ausgewählt wurden
            if count == total_points:
                reply = QMessageBox.question(None, "Alle Punkte ausgewählt", "Es wurden alle Punkte ausgewählt. " \
                                             "Möchten Sie fortfahren?",
                                     QMessageBox.Yes | QMessageBox.No)
                if reply == QMessageBox.No:
                    new_layer.removeSelection()
                    self.dlg.showNormal()
                    return
            
            reply = QMessageBox.question(None, "Werte überschreiben?", f"{count} Punkte wurden ausgewählt. " \
                                         "Möchten Sie die Werte dieser Punkte überschreiben?",
                                         QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                new_layer.startEditing()     
                selected_column = self.dlg.columnComboBox_Attribute.currentText()
                field_idx = new_layer.fields().indexOf(selected_column)
                
                if field_idx == -1:
                    QMessageBox.warning(None, "Feld nicht existent", f"Das Feld {selected_column} existiert nicht!")
                    return
                
                value_str, ok = QInputDialog.getText(None, "Wert eingeben", f"Gib den neuen Wert für das Feld {selected_column} ein:")
                if not value_str:
                    QMessageBox.warning(None, "Kein Wert eingegeben", "Bitte geben Sie einen Wert ein.")
                    return
                if not ok:
                    return
                
                # Feldtyp überprüfen und ggf. Typ der Eingabe anpassen
                field = new_layer.fields().field(field_idx)
                field_type = field.type()

                try:
                    if field_type == QVariant.Int:
                        value = int(value_str)
                    elif field_type == QVariant.LongLong:
                        try:
                            value = int(value_str)
                        except ValueError:
                            QMessageBox.warning(None, "Fehler", "Bitte eine Zahl eingeben!")
                            return
                    elif field_type == QVariant.Double:
                        value = float(value_str)
                    elif field_type == QVariant.String:
                        value = str(value_str)
                    elif field_type == QVariant.Bool:
                        value = value_str.lower() in ("1", "true", "ja", "yes")
                    elif field_type == QVariant.Date:
                        value = QDate.fromString(value_str, "yyyy-MM-dd")
                        if not value.isValid():
                            raise ValueError("Ungültiges Datum")
                    else:
                        # Fallback: als String einfügen (nicht optimal)
                        value = str(value)

                except Exception as e:
                    QMessageBox.warning(None, "Fehler", f"Ungültiger Eingabewert für Typ {field_type}: {e}")
                    return        
                
                for id in new_layer.selectedFeatureIds():
                    success = new_layer.changeAttributeValue(id, field_idx, value)
                    if not success:
                        QMessageBox.warning(self, "Fehler", "Attribut konnte nicht geändert werden.")

                # Frage nach weiterer Punkte-Auswahl
                morePoints = QMessageBox.question(None, "Mehr Punkte?", "Sollen weitere Punkte für das Attribut " \
                                         f"{selected_column} ausgewählt und geändert werden?",
                                         QMessageBox.Yes | QMessageBox.No)
                if morePoints == QMessageBox.No:
                    dialog.accept()                    
                    self.dlg.on_SymbButton_clicked()                    
                    self.dlg.showNormal()
                    iface.actionPan().trigger()
                
                new_layer.commitChanges()
            else:
                new_layer.removeSelection()     
    
    ########################    
    ### Cleanup Function ###    TO DO: muss überarbeitet werden
    ########################
    def cleanup_plugin_resources(self):
        """Löscht alle erstellten temporären Variablen, Layer und Datenframes des Plugins und löscht die Shapefiles."""

        # Remove existing layers if defined and valid
        if hasattr(self, 'new_layer') and self.new_layer is not None:
            QgsProject.instance().removeMapLayer(self.new_layer.id())
            self.new_layer = None

        if hasattr(self, 'copy_new_layer') and self.copy_new_layer is not None:
            QgsProject.instance().removeMapLayer(self.copy_new_layer.id())
            self.copy_new_layer = None

        if hasattr(self, 'temp_feldgrenze') and self.temp_feldgrenze is not None:
            QgsProject.instance().removeMapLayer(self.temp_feldgrenze.id())
            self.temp_feldgrenze = None

        if hasattr(self, 'temp_innenflaeche') and self.temp_innenflaeche is not None:
            QgsProject.instance().removeMapLayer(self.temp_innenflaeche.id())
            self.temp_innenflaeche = None

        if hasattr(self, 'temp_parzelle') and self.temp_parzelle is not None:
            QgsProject.instance().removeMapLayer(self.temp_parzelle.id())
            self.temp_parzelle = None
            
        # Clean up data layers if present
        if hasattr(self, 'daten_layer'):
            self.daten_layer = None

        if hasattr(self, 'existing_selection'):
            self.existing_selection = None

        if hasattr(self, 'selected_features'):
            self.selected_features = None

        if hasattr(self, 'polygon_selection_tool'):
            self.polygon_selection_tool = None
            
        if hasattr(self, 'auswahl_tabelle'):
            self.auswahl_tabelle = None
            
        if hasattr(self, 'filterparameter_tabelle'):
            self.filterparameter_tabelle = None
            
        if hasattr(self, 'filter_punktauswahl'):
            self.filter_punktauswahl = None

        # Reset any stored CRS transformations
        if hasattr(self, 'crs_transform'):
            self.crs_transform = None

        # Reset file paths or directories if any were used
        if hasattr(self, 'ofr_filter_dir'):
            self.ofr_filter_dir = None