# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OFRFilterDialog
                                 A QGIS plugin
 Filtering Point Data for On-Farm Experiments
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-09-03
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Sebastian Ramm
        email                : sebastian.ramm@fh-kiel.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import pandas as pd

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import QgsProject, QgsVectorLayer, QgsWkbTypes, QgsVectorFileWriter, QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsRasterLayer, QgsProviderRegistry, QgsPointXY, QgsRectangle, QgsField
from qgis.gui import QgsMapCanvas, QgsMapToolPan, QgsMapToolZoom
from qgis.PyQt.QtWidgets import QVBoxLayout
from qgis.PyQt.QtWidgets import QMessageBox
from qgis.utils import iface
from PyQt5.QtCore import QVariant, Qt
from PyQt5.QtWidgets import QTableWidgetItem, QVBoxLayout, QDialog, QHBoxLayout, QLabel, QComboBox, QPushButton
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import numpy as np
import itertools
from .ofr_LogManager import LogManager as log


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ofr_filter_dialog_base.ui'))


class OFRFilterDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, ofr_filter_dir, plugin_instance, parent=None):
        """Initialisiert den Dialog und verknüpft GUI-Elemente mit Funktionen."""
        super(OFRFilterDialog, self).__init__(parent)

        # Informationen für Logging
        self.plugin_name = "OFR_Filter"
        self.plugin_version = "0.0.2"

        self.setupUi(self)
        self.setWindowFlags(Qt.WindowMinimizeButtonHint | Qt.WindowCloseButtonHint)  # Setze Fenster-Flags für Minimieren- und Schließen-Button
        self.ofr_filter_dir = ofr_filter_dir  # Speichert den Pfad des Zielordners
        self.plugin_instance = plugin_instance  # Referenz auf die Plugin-Instanz
        self.tabWidget.setCurrentIndex(0) # Setze den aktuellen Tab auf den ersten Tab (Index 0)
        self.tabWidget_Filter.setCurrentIndex(0)
        self.tabWidget_FilterViewer.setCurrentIndex(1)
        
        # Deaktivieren der Tabs beim Start
        self.tabWidget.setTabEnabled(1, False)
        self.tabWidget.setTabEnabled(2, False)
        
        # Button-Verbindungen
        self.pushButton.clicked.connect(self.on_ok_button_clicked)
        self.cutFG.clicked.connect(self.on_auf_Feldgrenze_zuschneiden_clicked)
        self.cutFB.clicked.connect(self.on_Vorgewende_abschneiden_clicked)
        self.cutPlot.clicked.connect(self.on_auf_Parzellen_zuschneiden_clicked)
        self.cutPoints.clicked.connect(self.on_polygon_selection_clicked)
        self.pushButton_Auswahl_Attribut.clicked.connect(self.on_point_selection_clicked)
        self.cutAF.clicked.connect(self.on_af_ausschliessen_clicked)
        self.exitButton.clicked.connect(self.on_cancel_button_clicked)
        self.SymbButton.clicked.connect(self.on_SymbButton_clicked)
        self.exitButton2.clicked.connect(self.on_cancel_button_clicked)
        self.WeiterButton.clicked.connect(self.on_weiter_button_clicked)
        self.BackButton.clicked.connect(self.on_back_button_clicked)
        self.untergrenze.clicked.connect(self.on_untergrenze_anwenden_clicked)
        self.obergrenze.clicked.connect(self.on_obergrenze_anwenden_clicked)
        self.pushButton_SD.clicked.connect(self.on_sd_anwenden_clicked)
        self.untergrenze_reset.clicked.connect(self.on_untergrenze_reset_clicked)
        self.obergrenze_reset.clicked.connect(self.on_obergrenze_reset_clicked)
        self.pushButton_SD_reset.clicked.connect(self.on_sd_reset_clicked)
        self.pushButton_Attribute.clicked.connect(self.on_attribut_button_clicked)
        self.pushButton_Beenden.clicked.connect(self.on_exit_button_clicked)
        self.WeiterButton2.clicked.connect(self.on_weiter_button_2_clicked)
        self.resetButton.clicked.connect(self.reset_filters)
        self.pushButton_Attribut_anlegen.clicked.connect(self.on_attribut_anlegen_clicked)
        self.pushButton_auswahl_Parzelle.clicked.connect(self.show_polygon_layer_selector)
        
        # Deaktivieren der ComboBoxen beim Start
        self.mMapLayerComboBox_Parzellen.setEnabled(False)
        self.mMapLayerComboBox_Innenflaeche.setEnabled(False)
        self.mMapLayerComboBox_Feldgrenze.setEnabled(False)
        self.mMapLayerComboBox_AF.setEnabled(False)
        self.columnComboBox.setEnabled(False)
        self.mComboBox_Plots.setEnabled(False)
        self.groupBox_fehlendeParzelle.setEnabled(False)
        self.groupBox_fehlendeParzelle.hide()

        # Initialisieren der Buttons
        self.update_button_states()

        # Verknüpfen der ComboBox-Signale mit der Button-Aktivierungs- und Überprüfungsfunktion
        self.mMapLayerComboBox_Feldgrenze.currentIndexChanged.connect(self.on_combobox_changed)
        self.mMapLayerComboBox_Innenflaeche.currentIndexChanged.connect(self.on_combobox_changed)
        self.mMapLayerComboBox_Parzellen.currentIndexChanged.connect(self.on_combobox_changed)
        self.mMapLayerComboBox_AF.currentIndexChanged.connect(self.on_combobox_changed)
        self.mMapLayerComboBox_Daten.currentIndexChanged.connect(self.validate_and_update_buttons)
        self.columnComboBox.currentIndexChanged.connect(self.validate_and_update_buttons)
        
        # Label formatieren
        self.Attribut_label.setStyleSheet("background-color: white;")
        self.Attribut_label1.setStyleSheet("background-color: white;")
        
        # Label initialisieren
        self.count_LB_label.setText("kein Filter angewand")
        self.count_UB_label.setText("kein Filter angewand")
        self.label_auswahl.setText("keine Filter angewand")
        self.count_SD_label.setText("keine Filter angewand")
        self.label_auswahl_rel.setText("")      
      
        # Verknüpfen der ComboBox-Signale mit der Aktuallisierung der Label und LB, UB Grenzwerten
        self.columnComboBox2.currentIndexChanged.connect(self.on_attribut_changed)
        
        # Verknüpfung der Reiter und Checkbox mit der Aktuallisierung der Histogramme
        self.tabWidget_Filter.currentChanged.connect(self.create_histograms)
        self.checkBox_hist.stateChanged.connect(self.create_histograms)
        
        # Füllen von ComboBoxen
        self.populate_combobox_LB_UB()
        self.populate_combobox_SD()
        
        # Fertig-Status
        self.fertig = 0
        
        # Close-Status
        self.is_closing = False
        
        # Für Testversion
        self.tabWidget_Filter.setTabEnabled(2, False)
        self.tabWidget_FilterViewer.setTabEnabled(2, False)

    ################################
    ### Daten laden, prüfen usw. ###
    ################################        

    def testPush(self):
        text = str(self.mMapLayerComboBox_Daten.currentLayer())
        QMessageBox.information(self, "Info", text)
            

    def on_combobox_changed(self):
        self.validate_and_update_buttons()
        self.fill_map_widget_zuschneiden()
    
    
    def validate_and_update_buttons(self):
        """Validiert die Layer und aktiviert/deaktiviert die Buttons entsprechend."""
        valid = self.validate_layers()  # Führt die Validierung aus

        # Aktualisiere die Buttons, wenn die Validierung erfolgreich war
        if valid:
            self.update_button_states()

    def validate_layers(self):
        """Überprüft alle relevanten ComboBoxen und zeigt eine Fehlermeldung bei falscher Auswahl."""
        
        # Überprüfen, ob der daten_layer ein Punktlayer ist
        daten_layer = self.mMapLayerComboBox_Daten.currentLayer()
        if daten_layer is not None and not self.is_valid_point_layer(daten_layer):
            QMessageBox.critical(self, "Fehler", "Auswahl nicht korrekt: Es muss ein Punkt-Vektorlayer für 'Daten' gewählt werden.")
            self.mMapLayerComboBox_Daten.setCurrentIndex(-1)  # Setze die Auswahl zurück
            return False  # Validierung fehlgeschlagen

        # Überprüfen, ob der Parzellen-Layer ein Polygonlayer ist
        parzellen_layer = self.mMapLayerComboBox_Parzellen.currentLayer()
        if parzellen_layer is not None and not self.is_valid_polygon_layer(parzellen_layer):
            QMessageBox.critical(self, "Fehler", "Auswahl nicht korrekt: Es muss ein Polygon-Vektorlayer für 'Parzellen' gewählt werden.")
            self.mMapLayerComboBox_Parzellen.setCurrentIndex(-1)  # Setze die Auswahl zurück
            return False

        # Überprüfen, ob der Innenfläche-Layer ein Polygonlayer ist
        innenflaeche_layer = self.mMapLayerComboBox_Innenflaeche.currentLayer()
        if innenflaeche_layer is not None and not self.is_valid_polygon_layer(innenflaeche_layer):
            QMessageBox.critical(self, "Fehler", "Auswahl nicht korrekt: Es muss ein Polygon-Vektorlayer für 'Innenfläche' gewählt werden.")
            self.mMapLayerComboBox_Innenflaeche.setCurrentIndex(-1)
            return False

        # Überprüfen, ob der Feldgrenze-Layer ein Polygonlayer ist
        feldgrenze_layer = self.mMapLayerComboBox_Feldgrenze.currentLayer()
        if feldgrenze_layer is not None and not self.is_valid_polygon_layer(feldgrenze_layer):
            QMessageBox.critical(self, "Fehler", "Auswahl nicht korrekt: Es muss ein Polygon-Vektorlayer für 'Feldgrenze' gewählt werden.")
            self.mMapLayerComboBox_Feldgrenze.setCurrentIndex(-1)
            return False

        # Überprüfen, ob der AF-Layer ein Polygonlayer ist
        af_layer = self.mMapLayerComboBox_AF.currentLayer()
        if af_layer is not None and not self.is_valid_polygon_layer(af_layer):
            QMessageBox.critical(self, "Fehler", "Auswahl nicht korrekt: Es muss ein Polygon-Vektorlayer für 'AF' gewählt werden.")
            self.mMapLayerComboBox_AF.setCurrentIndex(-1)
            return False
            
        # Überprüft, ob Spalten für die Symbolisierung zur Auswahl stehen
        if self.columnComboBox.currentText is None:
            return False

        return True  # Alle Validierungen bestanden

    def on_ok_button_clicked(self):
        """Überprüft die Benutzerauswahl und fügt den Daten-Layer hinzu."""
        daten_layer = self.mMapLayerComboBox_Daten.currentLayer()

        if not self.is_valid_point_layer(daten_layer):
            QMessageBox.critical(self, "Fehler", "Auswahl nicht korrekt: Es muss ein Punkt-Vektorlayer für 'Daten' gewählt werden.")
            return

        # Wenn die Prüfung erfolgreich ist, die ComboBox für "Daten" deaktivieren (ausgrauen)
        self.mMapLayerComboBox_Daten.setEnabled(False)
        
        
        # Jetzt die anderen ComboBoxen aktivieren, wenn der daten_layer valid ist
        self.mMapLayerComboBox_Parzellen.setEnabled(True)
        self.mMapLayerComboBox_Innenflaeche.setEnabled(True)
        self.mMapLayerComboBox_Feldgrenze.setEnabled(True)
        self.mMapLayerComboBox_AF.setEnabled(True)

        # Layer erzeugen
        self.plugin_instance.add_filtered_layer(daten_layer, self.ofr_filter_dir)

        # Aktualisiere die Buttons nach dem Datenladen
        self.update_button_states()

        # LogManager initialisieren
        self.log = log(self.mMapLayerComboBox_Daten.currentText(), QgsProject.instance().homePath())
        self.log.set_plugin_info(self.plugin_name, self.plugin_version)
        #QMessageBox.information(None, "bla", f"Das ist {daten_layer}")

        #self.log = self.plugin_instance.init_log_manager(daten_layer.source)
        #LogManager(actual_layer_name, actual_project_path)
        

    def update_button_states(self):
        """Aktualisiert den Aktivierungsstatus der Buttons basierend auf den ausgewählten Layern."""
        daten_layer_valid = hasattr(self, 'new_layer') and self.new_layer is not None
        
        # Buttons basierend auf Layer-Validität aktivieren/deaktivieren
        self.cutFG.setEnabled(daten_layer_valid and self.is_valid_polygon_layer(self.mMapLayerComboBox_Feldgrenze.currentLayer()))
        self.cutFB.setEnabled(daten_layer_valid and self.is_valid_polygon_layer(self.mMapLayerComboBox_Innenflaeche.currentLayer()))
        self.cutPlot.setEnabled(daten_layer_valid and self.is_valid_polygon_layer(self.mMapLayerComboBox_Parzellen.currentLayer()))
        self.cutAF.setEnabled(daten_layer_valid and self.is_valid_polygon_layer(self.mMapLayerComboBox_AF.currentLayer()))
        self.cutPoints.setEnabled(hasattr(self, 'new_layer') and self.new_layer is not None)
        self.SymbButton.setEnabled(hasattr(self, 'new_layer') and self.new_layer is not None and self.columnComboBox.currentText is not None)

    def is_valid_point_layer(self, layer):
        """Überprüft, ob der Layer ein gültiger Punkt-Layer ist."""
        return layer is not None and QgsWkbTypes.geometryType(layer.wkbType()) == QgsWkbTypes.PointGeometry

    def is_valid_polygon_layer(self, layer):
        """Überprüft, ob der Layer ein gültiger Polygon-Layer ist."""
        return layer is not None and QgsWkbTypes.geometryType(layer.wkbType()) == QgsWkbTypes.PolygonGeometry
        
    def populate_column_combobox(self, new_layer):
        """Fügt nur numerische Spalten des Layers in die QComboBox ein."""
        # Entferne alle existierenden Einträge in der ComboBox
        self.columnComboBox.clear()
        self.columnComboBox2.clear()
        self.columnComboBox_Attribute.clear()

        # Hole die Feldnamen (Spaltennamen) des Layers
        fields = new_layer.fields()
        
        # Füge eine leere Auswahl an erster Stelle hinzu
        self.columnComboBox.addItem("")

        # Füge nur numerische Spalten in die ComboBox ein
        for field in fields:
            if field.type() in (QVariant.Int, QVariant.Double, QVariant.LongLong, QVariant.UInt, QVariant.ULongLong):
                self.columnComboBox.addItem(field.name())
                self.columnComboBox2.addItem(field.name())
            self.columnComboBox_Attribute.addItem(field.name())

    def populate_attribut_combobox(self, new_layer):
        self.columnComboBox_Attribute.clear()
        fields = new_layer.fields()
        self.columnComboBox.addItem("")
        for field in fields:
            self.columnComboBox_Attribute.addItem(field.name())
            
    def on_SymbButton_clicked(self):
        if not self.columnComboBox.currentText() is None:
            self.plugin_instance.apply_graduated_style(self.new_layer, self.columnComboBox.currentText())

    
    #########################
    ### Daten zuschneiden ###
    #########################    
    def on_auf_Feldgrenze_zuschneiden_clicked(self):
        """Lösche Punkte außerhalb der Feldgrenze"""
        self.plugin_instance.lösche_punkte_ausserhalb_feldgrenze(self.new_layer, self.mMapLayerComboBox_Feldgrenze.currentLayer())
    
    def on_Vorgewende_abschneiden_clicked(self):
        """Lösche Punkte im Vorgewende"""
        self.plugin_instance.lösche_punkte_auf_Vorgewende(self.new_layer, self.mMapLayerComboBox_Innenflaeche.currentLayer())
        
    def on_auf_Parzellen_zuschneiden_clicked(self):
        """Lösche Punkte außerhalb der Parzellen"""
        self.plugin_instance.lösche_punkte_außerhalb_Parzellen(self.new_layer, self.mMapLayerComboBox_Parzellen.currentLayer())
        
    def on_polygon_selection_clicked(self):
        """Aktiviert das Polygon-Auswahlwerkzeug und minimiert das Fenster"""
        self.showMinimized()        
        self.plugin_instance.polygon_selection(self.new_layer)
        
    def on_af_ausschliessen_clicked(self):
        """Lösche Punkte in Ausschlussfläche"""
        self.plugin_instance.lösche_punkte_in_af(self.new_layer, self.mMapLayerComboBox_AF.currentLayer())
        
    def initialize_map_zuschnitt(self):
        """Initialisiert die Zuschnitt-Karte mit OpenStreetMap XYZ-Kachelkarte und zoomt auf eine spezifische Koordinate."""
                
        # Zuschnitt-Karte initialisieren
        self.mapCanvas = QgsMapCanvas()
        self.mapCanvas.setCanvasColor(Qt.white)
        self.layout_map = QVBoxLayout(self.mapWidget)              
        self.layout_map.addWidget(self.mapCanvas)
                
        # Setze den Ziel-CRS des MapCanvas auf EPSG:3857 (Web Mercator)
        epsg_3857 = QgsCoordinateReferenceSystem("EPSG:3857")
        self.mapCanvas.setDestinationCrs(epsg_3857)
        
        # Pan-Werkzeug (zum Verschieben der Karte)
        self.pan_tool = QgsMapToolPan(self.mapCanvas)
        self.mapCanvas.setMapTool(self.pan_tool)
        
        # OpenStreetMap XYZ-Kachelkarte als Hintergrund hinzufügen
        url_with_params = 'type=xyz&url=https://tile.openstreetmap.org/{z}/{x}/{y}.png&zmax=19&zmin=0'
        self.osm_layer = QgsRasterLayer(url_with_params, 'OpenStreetMap', 'wms')
        print("OSM")

        # Überprüfe, ob der Layer gültig ist
        if self.osm_layer.isValid():
            # Setze self.osm_layer als Hintergrundkarte und speichere sie als Instanzvariable
            self.background_layer = self.osm_layer
            # Füge den Layer explizit zur MapCanvas hinzu
            self.mapCanvas.setLayers([self.background_layer])
            print("layer hinzugrfügt")
        else:
            print("OpenStreetMap layer ist nicht gültig")

        # Koordinaten in EPSG:4326 (Breitengrad/Längengrad)
        lat, lon = 54.287872, 9.674358  # 54°17'16.34"N, 9°40'27.69"E

        # Transformiere die Koordinate in den Ziel-CRS (EPSG:3857)
        source_crs = QgsCoordinateReferenceSystem("EPSG:4326")  # WGS 84 (Breiten-/Längengrade)
        transform_context = QgsProject.instance().transformContext()
        coordinate_transform = QgsCoordinateTransform(source_crs, epsg_3857, transform_context)

        # Erstelle den Punkt und transformiere ihn
        point_4326 = QgsPointXY(lon, lat)
        point_3857 = coordinate_transform.transform(point_4326)
        print(point_3857)

        # Zoome auf die transformierte Koordinate
        self.mapCanvas.setExtent(QgsRectangle(point_3857.x() - 250, point_3857.y() - 250, point_3857.x() + 250, point_3857.y() + 250))
        self.mapCanvas.refresh()
        print("fertig")
        print( self.background_layer == None)

       
    def fill_map_widget_zuschneiden(self):
        """Füllt das Map-Widget mit den Layern und zoomt auf den new_layer."""
        
        # Überprüfe, ob new_layer existiert
        if hasattr(self, 'new_layer') and self.new_layer is not None:
            
            # Stelle sicher, dass die Hintergrundkarte immer enthalten ist
            layers_to_add = [self.background_layer] if hasattr(self, 'background_layer') and self.background_layer else []

            # Füge die anderen Layer zur Liste hinzu, falls sie existieren
            feldgrenze_layer = self.mMapLayerComboBox_Feldgrenze.currentLayer()
            innenfaelche_layer = self.mMapLayerComboBox_Innenflaeche.currentLayer()
            parzellen_layer = self.mMapLayerComboBox_Parzellen.currentLayer()
            af_layer = self.mMapLayerComboBox_AF.currentLayer()

            if feldgrenze_layer:
                layers_to_add.append(feldgrenze_layer)
            if innenfaelche_layer:
                layers_to_add.append(innenfaelche_layer)
            if parzellen_layer:
                layers_to_add.append(parzellen_layer)
            if af_layer:
                layers_to_add.append(af_layer)

            # Füge den new_layer als oberste Ebene hinzu
            layers_to_add.append(self.new_layer)

            # Sortiere die Layer in der gewünschten Reihenfolge
            sorted_layers = self.sort_layers_by_priority(layers_to_add)

            # Setze die sortierte Layer-Liste im MapCanvas
            self.mapCanvas.setLayers(sorted_layers)

            # Setze den Ziel-CRS des MapCanvas auf EPSG:3857 (Web Mercator)
            epsg_3857 = QgsCoordinateReferenceSystem("EPSG:3857")
            self.mapCanvas.setDestinationCrs(epsg_3857)

            # Transformiere die extent des new_layer zum Ziel-CRS (EPSG:3857)
            layer_crs = self.new_layer.crs()
            transform_context = QgsProject.instance().transformContext()
            coordinate_transform = QgsCoordinateTransform(layer_crs, epsg_3857, transform_context)

            # Transformiere die Extent in den Ziel-CRS (EPSG:3857)
            transformed_extent = coordinate_transform.transformBoundingBox(self.new_layer.extent())

            # Zoome auf die transformierte Extent
            self.mapCanvas.setExtent(transformed_extent)
            self.mapCanvas.refresh()

    def update_map_zuschneiden_new_layer(self):
        """Aktualisiert den new_layer im MapCanvas und zoomt auf ihn in der richtigen Reihenfolge."""

        # Überprüfe, ob new_layer existiert
        if hasattr(self, 'new_layer') and self.new_layer is not None:
            
            # Stelle sicher, dass die Hintergrundkarte immer enthalten ist
            current_layers = [self.background_layer] if hasattr(self, 'background_layer') and self.background_layer else []

            # Holen der aktuellen Layer im MapCanvas
            canvas_layers = self.mapCanvas.layers()

            # Entfernen des aktuellen new_layer, falls er schon in der Karte ist
            canvas_layers = [layer for layer in canvas_layers if layer != self.new_layer]

            # Füge den aktualisierten new_layer hinzu
            current_layers.extend(canvas_layers)
            current_layers.append(self.new_layer)

            # Sortiere die Layer in der richtigen Reihenfolge
            sorted_layers = self.sort_layers_by_priority(current_layers)

            # Setze die aktualisierte Layer-Liste im MapCanvas
            self.mapCanvas.setLayers(sorted_layers)

            # Zoome auf den new_layer
            layer_crs = self.new_layer.crs()
            transform_context = QgsProject.instance().transformContext()
            epsg_3857 = QgsCoordinateReferenceSystem("EPSG:3857")
            coordinate_transform = QgsCoordinateTransform(layer_crs, epsg_3857, transform_context)

            transformed_extent = coordinate_transform.transformBoundingBox(self.new_layer.extent())
            self.mapCanvas.setExtent(transformed_extent)
            self.mapCanvas.refresh()

    def sort_layers_by_priority(self, layers):
        """Sortiert die Layer nach der gewünschten Priorität."""
        
        priority_order = {
            self.background_layer: 6, 
            self.mMapLayerComboBox_Feldgrenze.currentLayer(): 5,
            self.mMapLayerComboBox_Innenflaeche.currentLayer(): 4,
            self.mMapLayerComboBox_Parzellen.currentLayer(): 3,
            self.mMapLayerComboBox_AF.currentLayer(): 2,
            self.new_layer: 1            
        }

        # Rückgabe der sortierten Layer anhand der Priorität
        return sorted(layers, key=lambda layer: priority_order.get(layer, 6))
    
    ##############
    ### Filter ###
    ##############
    
    def on_attribut_changed(self):
        """Aktualisierungen, wenn das Attribut geändert wurde"""
        # Setze Attribut-Labels
        self.Attribut_label.setText(self.columnComboBox2.currentText())
        self.Attribut_label1.setText(self.columnComboBox2.currentText())
                
        # Hole den neuen Attribut-Namen aus columnComboBox2
        selected_column = self.columnComboBox2.currentText()
                       
        # Setzte Anzahl-Auswahl-Labels
        
        if hasattr(self.plugin_instance, 'auswahl_tabelle') and self.plugin_instance.auswahl_tabelle is not None: 
            lb_anzahl = self.plugin_instance.auswahl_tabelle.at[0, selected_column]
            ub_anzahl = self.plugin_instance.auswahl_tabelle.at[1, selected_column]
            sd_anzahl = self.plugin_instance.auswahl_tabelle.at[2, selected_column]
            
            if pd.isna(lb_anzahl):
                self.count_LB_label.setText("kein Filter angewand")
            else:
                self.count_LB_label.setText(f"Anzahl ausgewählter Punkte: {lb_anzahl}")
                
            if pd.isna(ub_anzahl):
                self.count_UB_label.setText("kein Filter angewand")
            else:
                self.count_UB_label.setText(f"Anzahl ausgewählter Punkte: {ub_anzahl}") 
                
            if pd.isna(sd_anzahl):
                self.count_SD_label.setText("kein Filter angewand")
            else:
                self.count_SD_label.setText(f"Anzahl ausgewählter Punkte: {sd_anzahl}")
        
        # set parameter in der SpinBox für Untergrenze, Obergrenze, Standardabweichung
        if hasattr(self.plugin_instance, 'filterparameter_tabelle') and self.plugin_instance.filterparameter_tabelle is not None:
            value_lb = self.plugin_instance.filterparameter_tabelle.at[0, selected_column] # Lese den Wert aus der Tabelle (Zeile 1 für Untergrenze)
            method_lb = self.plugin_instance.filterparameter_tabelle.at[1, selected_column] # Lese Methode aus der Tabelle (Zeile 2 für Untergrenze)
            value_ub = self.plugin_instance.filterparameter_tabelle.at[2, selected_column] # Lese den Wert aus der Tabelle (Zeile 3 für Obergrenze)
            method_ub = self.plugin_instance.filterparameter_tabelle.at[3, selected_column] # Lese Methode aus der Tabelle (Zeile 4 für Obergrenze)
            value_sd = self.plugin_instance.filterparameter_tabelle.at[4, selected_column] # Lese den Wert aus der Tabelle (Zeile 5 für Obergrenze)
            method_sd = self.plugin_instance.filterparameter_tabelle.at[5, selected_column] # Lese Methode aus der Tabelle (Zeile 6 für Obergrenze)
            
            # Untergrenze Parameter
            if pd.isna(value_lb): # Wenn der Wert NaN ist, setze den Wert der SpinBox auf 0, sonst auf den Wert aus der Tabelle
                self.doubleSpinBox_LB.setValue(0)
            else:
                self.doubleSpinBox_LB.setValue(value_lb)
            # Untergrenze Methode
            if pd.isna(method_lb): # Wenn der Wert NaN ist, setze Index auf 0
                self.comboBox_LB.setCurrentIndex(0)
            else:
                self.comboBox_LB.setCurrentIndex(method_lb)
            
            # Obergrenze Parameter
            if pd.isna(value_ub): # Wenn der Wert NaN ist, setze den Wert der SpinBox auf 0, sonst auf den Wert aus der Tabelle
                self.doubleSpinBox_UB.setValue(0)
            else:
                self.doubleSpinBox_UB.setValue(value_ub)
            # Obergrenze Methode
            if pd.isna(method_ub): # Wenn der Wert NaN ist, setze Index auf 0
                self.comboBox_UB.setCurrentIndex(0)
            else:
                self.comboBox_UB.setCurrentIndex(method_ub)
                
            # Standardabweichung Parameter
            if pd.isna(value_sd): # Wenn der Wert NaN ist, setze den Wert der SpinBox auf 2, sonst auf den Wert aus der Tabelle
                self.doubleSpinBox_SD.setValue(2)
            else:
                self.doubleSpinBox_SD.setValue(value_sd)
            # Standardabweichung Methode
            if pd.isna(method_sd): # Wenn der Wert NaN ist, setze Index auf 0
                self.comboBox_sd.setCurrentIndex(0)
            else:
                self.comboBox_sd.setCurrentIndex(method_sd)
                
        if self.tabWidget.currentIndex() == 1:
            # Aktualisiere die Anzeige des Canvas
            self.create_histograms()
    
    def populate_combobox_LB_UB(self):
        """Drop-Downs für Ober- und Untergrenzenfilter füllen"""
        self.comboBox_LB.addItem("<")
        self.comboBox_LB.addItem("≤")
        self.comboBox_UB.addItem(">")
        self.comboBox_UB.addItem("≥")
        
    def populate_combobox_SD(self):
        """Drop-Down für MEthode Standardabweichung"""
        self.comboBox_sd.addItem("Ober- und Untergrenze")
        self.comboBox_sd.addItem("Untergrenze")
        self.comboBox_sd.addItem("Obergrenze")
        
    def fill_table_widget(self, table_widget, df):
        """ Füllt ein QTableWidget mit den Daten eines Pandas DataFrame."""
        # Setze die Anzahl der Zeilen und Spalten im QTableWidget
        table_widget.setRowCount(len(df))
        table_widget.setColumnCount(len(df.columns))

        # Setze die Spaltennamen
        table_widget.setHorizontalHeaderLabels(df.columns)

        # Fülle das QTableWidget mit den Werten aus dem DataFrame
        for row_idx, row in df.iterrows():
            for col_idx, value in enumerate(row):
                # Falls der Wert None ist, setze ihn als leeren String
                if pd.isna(value):
                    value = ""
                table_widget.setItem(row_idx, col_idx, QTableWidgetItem(str(value)))
                
    def clear_table_widget_completely(self, table_widget):
        """ Leert das QTableWidget vollständig, einschließlich aller Einträge und Spaltennamen."""
        # Löscht den gesamten Inhalt der Tabelle, inklusive Spaltennamen
        table_widget.clear()
        
        # Setzt die Anzahl der Zeilen und Spalten auf 0
        table_widget.setRowCount(0)
        table_widget.setColumnCount(0)
    
    def reset_spinboxes(self):
        self.doubleSpinBox_LB.setValue(0)
        self.doubleSpinBox_UB.setValue(0)
        self.doubleSpinBox_SD.setValue(2)
        
    def reset_filters(self):
        antwort = QMessageBox.question(self, 'Bestätigung', 
                                     'Möchten Sie die Filter wirklich zurücksetzen?', 
                                     QMessageBox.Yes | QMessageBox.No, 
                                     QMessageBox.No)
        
        if antwort == QMessageBox.Yes:
            # Auswahltabelle zurücksetzen und Darstellung löschen
            self.auswahl_tabelle = None
            self.clear_table_widget_completely(self.tableWidget_Auswahl)
            # Filterparametertabelle zurücksetzen
            self.filterparameter_tabelle = None
            # Multiindex Dataframe für filterbasierte Punktauswahl zurücksetzen
            self.filter_punktauswahl = None
            # Auswahl zurücksetzen
            self.new_layer.removeSelection()
            # Auswahl-Liste zurücksetzen
            self.punktauswahl_gesamt = None
            # Auswahl-Zähler zurücksetzen
            self.gesamtauswahl = None
            # Lable zurücksetzen
            self.count_LB_label.setText("kein Filter angewand")
            self.count_UB_label.setText("kein Filter angewand")
            self.count_SD_label.setText("kein Filter angewand")
            self.label_auswahl.setText("keine Filter angewand")
            self.label_auswahl_rel.setText("")
            # SpinBoxes zurücksetzen        
            self.reset_spinboxes()
            # Aktualisiere die Anzeige des Canvas
            self.create_histograms()
            
            ### Filter wieder initialisieren
            # Auswahltabelle erstellen und füllen
            self.plugin_instance.create_auswahl_tabelle(self.new_layer)
            self.fill_table_widget(self.tableWidget_Auswahl, self.plugin_instance.auswahl_tabelle)
            # Filterparametertabelle erstellen und füllen
            self.plugin_instance.create_filterparameter_tabelle(self.new_layer)
            # Multiindex Dataframe für filterbasierte Punktauswahl erstellen
            self.plugin_instance.create_multiindex_punktauswahl(self.new_layer)
    
    

    def create_histograms(self):
        # Nicht durchführen, wenn geschlossen wird
        if self.is_closing:
            return
        
        # Hole den Spaltennamen aus der ComboBox
        column_name = self.columnComboBox2.currentText()

        # Prüfen, ob der Tab "Ober- und Untergrenze-Filter" ausgewählt ist
        if self.tabWidget_Filter.currentIndex() == 0 and self.tabWidget.currentIndex() == 1:
            # Hole die Daten aus dem Layer und konvertiere sie in float, wenn möglich
            values = [float(feat[column_name]) for feat in self.new_layer.getFeatures() if feat[column_name] is not None and self.is_numeric(feat[column_name])]

            if self.checkBox_hist.isChecked():
                alle_filter_punkte = self.plugin_instance.punktauswahl_gesamt               
                alle_filter_punkte_flat = list(itertools.chain.from_iterable(alle_filter_punkte)) if any(isinstance(i, list) for i in alle_filter_punkte) else alle_filter_punkte               
                alle_filter_punkte_set = set(alle_filter_punkte_flat)
                
                # Erstelle die gefilterten Daten
                filtered_values = []
                for feat in self.new_layer.getFeatures():
                    feat_id = feat.id()
                    if feat_id not in alle_filter_punkte_set and feat[column_name] is not None and self.is_numeric(feat[column_name]):
                        filtered_values.append(float(feat[column_name])) 
            else: 
                # Hole die Zeilenindizes aus dem MultiIndex DataFrame (Untergrenze & Obergrenze)
                untergrenze_indices = self.plugin_instance.filter_punktauswahl.loc['Untergrenze', column_name].tolist()
                obergrenze_indices = self.plugin_instance.filter_punktauswahl.loc['Obergrenze', column_name].tolist()

                # Flache die Listen, falls sie verschachtelt sind (Liste von Listen)
                untergrenze_indices_flat = list(itertools.chain.from_iterable(untergrenze_indices)) if any(isinstance(i, list) for i in untergrenze_indices) else untergrenze_indices
                obergrenze_indices_flat = list(itertools.chain.from_iterable(obergrenze_indices)) if any(isinstance(i, list) for i in obergrenze_indices) else obergrenze_indices

                # Konvertiere flache Listen in Sets für effizienteres Filtern
                untergrenze_indices_set = set(untergrenze_indices_flat)
                obergrenze_indices_set = set(obergrenze_indices_flat)

                # Erstelle die gefilterten Daten (ohne Zeilen aus Unter- und Obergrenze)
                filtered_values = []
                for feat in self.new_layer.getFeatures():
                    feat_id = feat.id()
                    if feat_id not in untergrenze_indices_set and feat_id not in obergrenze_indices_set and feat[column_name] is not None and self.is_numeric(feat[column_name]):
                        filtered_values.append(float(feat[column_name]))

            # Hole die Werte für Ober- und Untergrenze
            ub_value = self.plugin_instance.filterparameter_tabelle.at[0, column_name]
            lb_value = self.plugin_instance.filterparameter_tabelle.at[2, column_name]

            # Falls das Histogramm-Canvas noch nicht existiert, erzeuge es
            if not hasattr(self, 'histogram_canvas'):
                self.figure = Figure(figsize=(10, 5), dpi=100)
                self.histogram_canvas = FigureCanvas(self.figure)
                self.histogram_layout = QVBoxLayout(self.histogramm)  # Layout für das Widget
                self.histogram_layout.addWidget(self.histogram_canvas)

            # Bereite die Achsen für zwei Histogramme vor
            self.figure.clear()
            self.figure.subplots_adjust(wspace=0.3)  # Erhöht den horizontalen Abstand (Standard ist 0.2)
            
            axes1 = self.figure.add_subplot(121)  # Linkes Histogramm
            axes2 = self.figure.add_subplot(122)  # Rechtes Histogramm

            # Plot des ersten Histogramms (Rohdaten)
            counts, bins, _ = axes1.hist(values, bins=50, color='blue', edgecolor='black')
            axes1.set_title(f"Rohdaten: {column_name}")
            if ub_value is not None:
                axes1.axvline(x=ub_value, color='red', linestyle='--')  # Obergrenze in Rot
            if lb_value is not None:
                axes1.axvline(x=lb_value, color='red', linestyle='--')  # Untergrenze in Rot

            # Plot des zweiten Histogramms (gefiltert)
            counts_filtered, bins_filtered, _ = axes2.hist(filtered_values, bins=50, color='blue', edgecolor='black')
            axes2.set_title(f"Ober- und Untergrenze: {column_name}")
            if ub_value is not None:
                axes2.axvline(x=ub_value, color='red', linestyle='--')  # Obergrenze in Rot
            if lb_value is not None:
                axes2.axvline(x=lb_value, color='red', linestyle='--')  # Untergrenze in Rot
            
            # Aktualisiere die Anzeige des Canvas
            self.histogram_canvas.draw()

            # Deskriptive Statistik
            selected_features = self.new_layer.selectedFeatures()  # Holen der aktuell ausgewählten Features           
            count = len(selected_features)
            total_points = self.new_layer.featureCount()
            
            if count + 3 >= total_points:
                self.raw_stat.setText(f"Mittelwert: {round(np.mean(values), 2)}; Standardabweichung: {round(np.std(values), 2)}; Min: {round(np.min(values), 2)}; Max: {round(np.max(values), 2)}")
                self.filter_stat.setText("Nicht genügend Punkte übrig")
            else: 
                self.raw_stat.setText(f"Mittelwert: {round(np.mean(values), 2)}; Standardabweichung: {round(np.std(values), 2)}; Min: {round(np.min(values), 2)}; Max: {round(np.max(values), 2)}")
                self.filter_stat.setText(f"Mittelwert: {round(np.mean(filtered_values), 2)}; Standardabweichung: {round(np.std(filtered_values), 2)}; Min: {round(np.min(filtered_values), 2)}; Max: {round(np.max(filtered_values), 2)}")
        
        elif self.tabWidget_Filter.currentIndex() == 1 and self.tabWidget.currentIndex() == 1:
            # Hole die Daten aus dem Layer und konvertiere sie in float, wenn möglich
            values = [float(feat[column_name]) for feat in self.new_layer.getFeatures() if feat[column_name] is not None and self.is_numeric(feat[column_name])]

            if self.checkBox_hist.isChecked():
                alle_filter_punkte = self.plugin_instance.punktauswahl_gesamt               
                alle_filter_punkte_flat = list(itertools.chain.from_iterable(alle_filter_punkte)) if any(isinstance(i, list) for i in alle_filter_punkte) else alle_filter_punkte               
                alle_filter_punkte_set = set(alle_filter_punkte_flat)
                
                # Erstelle die gefilterten Daten
                filtered_values = []
                for feat in self.new_layer.getFeatures():
                    feat_id = feat.id()
                    if feat_id not in alle_filter_punkte_set and feat[column_name] is not None and self.is_numeric(feat[column_name]):
                        filtered_values.append(float(feat[column_name])) 
            else: 
                # Hole die Zeilenindizes aus dem MultiIndex DataFrame (Standardabweichung)
                SD_indices = self.plugin_instance.filter_punktauswahl.loc['Standardabweichung', column_name].tolist()
                
                # Flache die Listen, falls sie verschachtelt sind (Liste von Listen)
                SD_indices_flat = list(itertools.chain.from_iterable(SD_indices)) if any(isinstance(i, list) for i in SD_indices) else SD_indices
                
                # Konvertiere flache Listen in Sets für effizienteres Filtern
                SD_indices_set = set(SD_indices_flat)
                
                # Erstelle die gefilterten Daten (ohne Zeilen aus Standardabweichung)
                filtered_values = []
                for feat in self.new_layer.getFeatures():
                    feat_id = feat.id()
                    if feat_id not in SD_indices_set and feat[column_name] is not None and self.is_numeric(feat[column_name]):
                        filtered_values.append(float(feat[column_name]))

            # Hole die Werte für SD- Ober- und Untergrenze
            sd_value = self.plugin_instance.filterparameter_tabelle.at[4, column_name]
            sd_ub = None
            sd_lb = None
            if self.plugin_instance.filterparameter_tabelle.at[5, column_name] == 0 and sd_value is not None:
                sd_ub = np.mean(values) + (sd_value * np.std(values))
                sd_lb = np.mean(values) - (sd_value * np.std(values))
            elif self.plugin_instance.filterparameter_tabelle.at[5, column_name] == 1 and sd_value is not None:
                sd_ub = None
                sd_lb = np.mean(values) - (sd_value * np.std(values))
            elif self.plugin_instance.filterparameter_tabelle.at[5, column_name] == 2 and sd_value is not None:
                sd_ub = np.mean(values) + (sd_value * np.std(values))
                sd_lb = None
            
            # Falls das Histogramm-Canvas noch nicht existiert, erzeuge es
            if not hasattr(self, 'histogram_canvas'):
                self.figure = Figure(figsize=(10, 5), dpi=100)
                self.histogram_canvas = FigureCanvas(self.figure)
                self.histogram_layout = QVBoxLayout(self.histogramm)  # Layout für das Widget
                self.histogram_layout.addWidget(self.histogram_canvas)

            # Bereite die Achsen für zwei Histogramme vor
            self.figure.clear()
            self.figure.subplots_adjust(wspace=0.3)  # Erhöht den horizontalen Abstand (Standard ist 0.2)
            
            axes1 = self.figure.add_subplot(121)  # Linkes Histogramm
            axes2 = self.figure.add_subplot(122)  # Rechtes Histogramm

            # Plot des ersten Histogramms (Rohdaten)
            counts, bins, _ = axes1.hist(values, bins=50, color='blue', edgecolor='black')
            axes1.set_title(f"Rohdaten: {column_name}")
            if sd_ub is not None:
                axes1.axvline(x=sd_ub, color='green', linestyle='--')  # Obergrenze in Rot
            if sd_lb is not None:
                axes1.axvline(x=sd_lb, color='green', linestyle='--')  # Untergrenze in Rot

            # Plot des zweiten Histogramms (gefiltert)
            counts_filtered, bins_filtered, _ = axes2.hist(filtered_values, bins=50, color='blue', edgecolor='black')
            axes2.set_title(f"Vielfachses der SD vom Mean: {column_name}")
            if sd_ub is not None:
                axes2.axvline(x=sd_ub, color='green', linestyle='--')  # Obergrenze in Rot
            if sd_lb is not None:
                axes2.axvline(x=sd_lb, color='green', linestyle='--')  # Untergrenze in Rot
            
            # Aktualisiere die Anzeige des Canvas
            self.histogram_canvas.draw()

            # Deskriptive Statistik
            selected_features = self.new_layer.selectedFeatures()  # Holen der aktuell ausgewählten Features           
            count = len(selected_features)
            total_points = self.new_layer.featureCount()
            
            if count + 3 >= total_points:
                self.raw_stat.setText(f"Mittelwert: {round(np.mean(values), 2)}; Standardabweichung: {round(np.std(values), 2)}; Min: {round(np.min(values), 2)}; Max: {round(np.max(values), 2)}")
                self.filter_stat.setText("Nicht genügend Punkte übrig")
            else: 
                self.raw_stat.setText(f"Mittelwert: {round(np.mean(values), 2)}; Standardabweichung: {round(np.std(values), 2)}; Min: {round(np.min(values), 2)}; Max: {round(np.max(values), 2)}")
                self.filter_stat.setText(f"Mittelwert: {round(np.mean(filtered_values), 2)}; Standardabweichung: {round(np.std(filtered_values), 2)}; Min: {round(np.min(filtered_values), 2)}; Max: {round(np.max(filtered_values), 2)}")

    # Hilfsfunktion, um zu prüfen, ob ein Wert numerisch ist
    def is_numeric(self, value):
        try:
            float(value)
            return True
        except (ValueError, TypeError):
            return False


       
    
    ########## Untergrenze ########## 
    def on_untergrenze_anwenden_clicked(self):
        # Hole den Wert aus doubleSpinBox_LB
        lb_value = self.doubleSpinBox_LB.value()

        # Hole den Spaltennamen aus columnComboBox2
        selected_column = self.columnComboBox2.currentText()
                
        # Setze den Wert in der Tabelle: Zeile 1 (Untergrenze) und die ausgewählte Spalte
        self.plugin_instance.filterparameter_tabelle.at[0, selected_column] = lb_value
        
        # Hole die die Methode
        method_lb = self.comboBox_LB.currentIndex()
        
        # Schreibe die MEthode in die Parametertabelle
        self.plugin_instance.filterparameter_tabelle.at[1, selected_column] = method_lb
        
        # Führe den Filter aus
        self.plugin_instance.filterfunction_untergrenze(self.new_layer)
        
        # Aktuallisiere die Filtertabelle
        self.fill_table_widget(self.tableWidget_Auswahl, self.plugin_instance.auswahl_tabelle)
        
        # Aktuallisiere das Lable
        self.count_LB_label.setText(f"Anzahl ausgewählter Punkte: {self.plugin_instance.auswahl_tabelle.at[0, selected_column]}")
        
        # Aktualisiere die Gesamtauswahl
        self.plugin_instance.combine_filter_punktauswahl(self.new_layer)
        
        # Aktualisiere die Anzeige des Canvas
        self.create_histograms()
        
    def on_untergrenze_reset_clicked(self):
        # Hole den Spaltennamen aus columnComboBox2
        selected_column = self.columnComboBox2.currentText()
        
        # Setze den Wert in der Tabelle Filterparameter: Zeile 1 (Untergrenze) und die ausgewählte Spalte auf NA
        self.plugin_instance.filterparameter_tabelle.at[0, selected_column] = None
        
        # Setze die Methode zurück
        self.plugin_instance.filterparameter_tabelle.at[1, selected_column] = None
        
        # SpinBox zurücksetzen
        self.doubleSpinBox_LB.setValue(0)
        
        # Setze die Auswhaltabelle zurück
        self.plugin_instance.auswahl_tabelle.at[0, selected_column] = None
        
        # filter_punktauswahl zurücksetzen
        self.plugin_instance.filter_punktauswahl.at[('Untergrenze', selected_column), 'Werte'] = None
        
        # Aktuallisiere die Filtertabelle
        self.fill_table_widget(self.tableWidget_Auswahl, self.plugin_instance.auswahl_tabelle)
        
        # aktualisiere das Lable
        self.count_LB_label.setText("kein Filter angewand")
        
        # Aktualisiere die Gesamtauswahl
        self.plugin_instance.combine_filter_punktauswahl(self.new_layer)
        
        # Aktualisiere die Anzeige des Canvas
        self.create_histograms()
        
    
    
    ########## Obergrenze ########## 
    def on_obergrenze_anwenden_clicked(self):
        # Hole den Wert aus doubleSpinBox_UB
        ub_value = self.doubleSpinBox_UB.value()

        # Hole den Spaltennamen aus columnComboBox2
        selected_column = self.columnComboBox2.currentText()
                
        # Setze den Wert in der Tabelle: Zeile 3 (Obergrenze) und die ausgewählte Spalte
        self.plugin_instance.filterparameter_tabelle.at[2, selected_column] = ub_value
        
        # Setze die Methode zurück
        self.plugin_instance.filterparameter_tabelle.at[3, selected_column] = None
        
        # Hole die die Methode
        method_ub = self.comboBox_UB.currentIndex()
        
        # Schreibe die MEthode in die Parametertabelle
        self.plugin_instance.filterparameter_tabelle.at[3, selected_column] = method_ub
        
        # Führe den Filter aus
        self.plugin_instance.filterfunction_obergrenze(self.new_layer)
        
        # Aktuallisiere die Filtertabelle
        self.fill_table_widget(self.tableWidget_Auswahl, self.plugin_instance.auswahl_tabelle)
        
        # Aktuallisiere das Lable
        self.count_UB_label.setText(f"Anzahl ausgewählter Punkte: {self.plugin_instance.auswahl_tabelle.at[1, selected_column]}")
        
        # Aktualisiere die Gesamtauswahl
        self.plugin_instance.combine_filter_punktauswahl(self.new_layer)
        
        # Aktualisiere die Anzeige des Canvas
        self.create_histograms()
        
    def on_obergrenze_reset_clicked(self):
        # Hole den Spaltennamen aus columnComboBox2
        selected_column = self.columnComboBox2.currentText()
        
        # Setze den Wert in der Tabelle Filterparameter: Zeile 3 (Obergrenze) und die ausgewählte Spalte auf NA
        self.plugin_instance.filterparameter_tabelle.at[2, selected_column] = None
        
        # SpinBox zurücksetzen
        self.doubleSpinBox_UB.setValue(0)
        
        # Setze die Auswhaltabelle zurück
        self.plugin_instance.auswahl_tabelle.at[1, selected_column] = None
        
        # filter_punktauswahl zurücksetzen
        self.plugin_instance.filter_punktauswahl.at[('Obergrenze', selected_column), 'Werte'] = None
        
        # Aktuallisiere die Filtertabelle
        self.fill_table_widget(self.tableWidget_Auswahl, self.plugin_instance.auswahl_tabelle)
        
        # aktualisiere das Lable
        self.count_UB_label.setText("kein Filter angewand")
        
        # Aktualisiere die Gesamtauswahl
        self.plugin_instance.combine_filter_punktauswahl(self.new_layer)
        
        # Aktualisiere die Anzeige des Canvas
        self.create_histograms()
        
    ########## Standardabweichung ##########
    def on_sd_anwenden_clicked(self):
        # Hole den Wert aus doubleSpinBox_UB
        sd_value = self.doubleSpinBox_SD.value()

        # Hole den Spaltennamen aus columnComboBox2
        selected_column = self.columnComboBox2.currentText()
                
        # Setze den Wert in der Tabelle: Zeile 5 (Multiplikator) und die ausgewählte Spalte
        self.plugin_instance.filterparameter_tabelle.at[4, selected_column] = sd_value
        
        # Setze die Methode zurück
        self.plugin_instance.filterparameter_tabelle.at[5, selected_column] = None
        
        # Hole die die Methode
        method_sd = self.comboBox_sd.currentIndex()
        
        # Schreibe die Methode in die Parametertabelle
        self.plugin_instance.filterparameter_tabelle.at[5, selected_column] = method_sd
        
        # Setze die Basis zurück
        self.plugin_instance.filterparameter_tabelle.at[6, selected_column] = None
        
        # Hole die die Basis
        basis = None
        if self.checkBox_SD.isChecked():
            basis = 1
        else:
            basis = 0
        
        # Schreibe die Basis in die Parametertabelle
        self.plugin_instance.filterparameter_tabelle.at[6, selected_column] = basis       
               
        # Führe den Filter aus
        self.plugin_instance.filterfunction_sd(self.new_layer)
        
        # Aktuallisiere die Filtertabelle
        self.fill_table_widget(self.tableWidget_Auswahl, self.plugin_instance.auswahl_tabelle)
        
        # Aktuallisiere das Lable
        self.count_SD_label.setText(f"Anzahl ausgewählter Punkte: {self.plugin_instance.auswahl_tabelle.at[2, selected_column]}")
        
        # Aktualisiere die Gesamtauswahl
        self.plugin_instance.combine_filter_punktauswahl(self.new_layer)
        
        # Aktualisiere die Anzeige des Canvas
        self.create_histograms()
        
    def on_sd_reset_clicked(self):
        # Hole den Spaltennamen aus columnComboBox2
        selected_column = self.columnComboBox2.currentText()
        
        # Setze die Werte in der Tabelle Filterparameter zurück
        self.plugin_instance.filterparameter_tabelle.at[4, selected_column] = None
        self.plugin_instance.filterparameter_tabelle.at[5, selected_column] = None
        self.plugin_instance.filterparameter_tabelle.at[6, selected_column] = None
        
        # SpinBox zurücksetzen
        self.doubleSpinBox_SD.setValue(2)
        
        # Setze die Auswhaltabelle zurück
        self.plugin_instance.auswahl_tabelle.at[2, selected_column] = None
        
        # filter_punktauswahl zurücksetzen
        self.plugin_instance.filter_punktauswahl.at[('Standardabweichung', selected_column), 'Werte'] = None
        
        # Aktuallisiere die Filtertabelle
        self.fill_table_widget(self.tableWidget_Auswahl, self.plugin_instance.auswahl_tabelle)
        
        # aktualisiere das Lable
        self.count_SD_label.setText("kein Filter angewand")
        
        # Aktualisiere die Gesamtauswahl
        self.plugin_instance.combine_filter_punktauswahl(self.new_layer)
        
        # Aktualisiere die Anzeige des Canvas
        self.create_histograms()

    ########################## 
    ### Attribute anfügen ###
    ##########################
        
    def attribute_anfügen_check(self):
        parzellen_layer = self.mMapLayerComboBox_Parzellen.currentLayer()
        if parzellen_layer is not None:
            self.mComboBox_Plots.clear()
            fields = parzellen_layer.fields()
            for field in fields:
                self.mComboBox_Plots.addItem(field.name())
            self.mComboBox_Plots.setEnabled(True)
        else:
            rp = QMessageBox.question(self, 'Kein Parzellen-Layer ausgewählt', 
                                         'Sie haben keinen Parzellen-Layer ausgewählt, um Parzellen-Attribute an den Punktdatensatz zu übertragen. Möchten Sie jetzt einen Layer auswählen?', 
                                         QMessageBox.Yes | QMessageBox.No, 
                                         QMessageBox.No)
                
            if rp == QMessageBox.Yes:
                self.show_polygon_layer_selector()
            else:
                self.close()

    def parzellen_layer_check(self, check:bool):
            parzellen_layer = self.mMapLayerComboBox_Parzellen.currentLayer()
            if parzellen_layer == None:
                self.groupBox_fehlendeParzelle.show()
                self.groupBox_fehlendeParzelle.setEnabled(True)
                self.groupBox_Parzellenattribute.setEnabled(False)
            else:                
                #self.groupBox_fehlendeParzelle.setEnabled(False)
                self.groupBox_Parzellenattribute.setEnabled(True)
                self.mComboBox_Plots.clear()
                fields = parzellen_layer.fields()
                for field in fields:
                    self.mComboBox_Plots.addItem(field.name())
                self.mComboBox_Plots.setEnabled(True)
                if check == True:
                    self.label_Parzellen_warnung.setText(parzellen_layer.name())
                    self.groupBox_fehlendeParzelle.setTitle("Parzellen-Layer ausgewählt:")
                else:                    
                    self.groupBox_fehlendeParzelle.hide()

                
                        
    def on_attribut_button_clicked(self):
        # Prüfen ob Attribute ausgewählt wurden
        selected_fields = self.mComboBox_Plots.checkedItems()  
        if not selected_fields:
            QMessageBox.warning(self, "Hinweis", "Bitte wähle mindestens ein Attribut aus.")
            return
        
        self.plugin_instance.attribute_anfügen(self.new_layer)
        
    def show_polygon_layer_selector(self):
        # Dialog erstellen
        dialog = QDialog(self)
        dialog.setWindowTitle("Parzellen-Layer auswählen")

        # Layouts
        layout = QVBoxLayout()
        dialog.setLayout(layout)

        # Label + ComboBox
        layout.addWidget(QLabel("Wähle einen Parzellen-Layer aus:"))
        combo = QComboBox()
        layout.addWidget(combo)

        # Polygon-Layer aus dem Projekt einfügen
        for layer in QgsProject.instance().mapLayers().values():
            if isinstance(layer, QgsVectorLayer) and QgsWkbTypes.geometryType(layer.wkbType()) == QgsWkbTypes.PolygonGeometry:
                combo.addItem(layer.name(), layer)

        # OK / Abbrechen Buttons
        button_layout = QHBoxLayout()
        ok_btn = QPushButton("OK")
        cancel_btn = QPushButton("Abbrechen")
        button_layout.addWidget(ok_btn)
        button_layout.addWidget(cancel_btn)
        layout.addLayout(button_layout)

        # Button-Verhalten
        ok_btn.clicked.connect(dialog.accept)
        cancel_btn.clicked.connect(dialog.reject)

        # Dialog anzeigen
        result = dialog.exec_()

        if result == QDialog.Accepted:
            selected_layer = combo.currentData()
            self.mMapLayerComboBox_Parzellen.setLayer(selected_layer)
            self.attribute_anfügen_check()
            self.parzellen_layer_check(True)                    

    def on_point_selection_clicked(self):
        self.showMinimized()        
        self.plugin_instance.point_selection(self.new_layer)

    # Bug: Wenn Spaltenname "Testattribut" angegeben wird -> Feld existiert nicht -> Herausfinden
    def on_attribut_anlegen_clicked(self):
        # Prüfen ob Attribute ausgewählt wurden
        attribut = self.lineEdit.text()
        self.neues_feld_anlegen(self.new_layer, attribut)

    def neues_feld_anlegen(self, new_layer, attribut):
        # Prüfen, ob Feld schon existiert
        if attribut in [f.name() for f in new_layer.fields()]:
            QMessageBox.warning(self, "Bereits vorhanden!", "Das eingegebene Attribut existiert bereits. Bitte " \
            "wählen Sie einen anderen Namen.")
            return
        
        if not self.new_layer.isEditable():
            self.new_layer.startEditing()

        # Neues Attribut hinzufügen
        if self.new_layer.dataProvider().addAttributes([QgsField(attribut, QVariant.String)]):
            self.new_layer.updateFields()
            QMessageBox.information(self, "Erfolg", "Attribut erfolgreich angelegt.")
            self.columnComboBox_Attribute.addItem(attribut)
            self.columnComboBox_Attribute.setCurrentText(attribut)
        else:
            QMessageBox.warning(self, "Fehler", "Das Attribut konnte nicht angelegt werden.")
            return    
    
    #########################
    ### Weiter und Zurück ###
    #########################
    def on_weiter_button_clicked(self):
        if hasattr(self, 'new_layer') and self.new_layer is not None:
            self.tabWidget.setTabEnabled(1, True)
            self.tabWidget.setCurrentIndex(1)
            self.tabWidget.setTabEnabled(0, False)

            # Auswahltabelle erstellen und füllen
            self.plugin_instance.create_auswahl_tabelle(self.new_layer)
            self.fill_table_widget(self.tableWidget_Auswahl, self.plugin_instance.auswahl_tabelle)
            # Filterparametertabelle erstellen und füllen
            self.plugin_instance.create_filterparameter_tabelle(self.new_layer)
            # Multiindex Dataframe für filterbasierte Punktauswahl erstellen
            self.plugin_instance.create_multiindex_punktauswahl(self.new_layer)
            # Aktualisiere die Histogramme
            self.create_histograms()
            # Zuschnitt-Karte zurücksetzen
            self.mapCanvas.setLayers([])
            self.mapCanvas.refresh()

            # Log
            self.log.set_layer_info(
                punkt_layer = self.mMapLayerComboBox_Daten.currentText(),
                parzellen_layer = self.mMapLayerComboBox_Parzellen.currentText() if self.mMapLayerComboBox_Parzellen.currentText() else "Nicht angegeben",
                innenflaeche_layer = self.mMapLayerComboBox_Innenflaeche.currentText() if self.mMapLayerComboBox_Innenflaeche.currentText() else "Nicht angegeben",
                feldgrenze_layer = self.mMapLayerComboBox_Feldgrenze.currentText() if self.mMapLayerComboBox_Feldgrenze.currentText() else "Nicht angegeben",                
                ausschlussflaeche_layer = self.mMapLayerComboBox_AF.currentText() if self.mMapLayerComboBox_AF.currentText() else "Nicht angegeben",
                filter_layer = self.new_layer.name()
            )

        else:
            QMessageBox.critical(self, "Fehler", "Sie müssen einen Punktdatensatz auswählen")
            
    def on_weiter_button_2_clicked(self):
        selected_features = self.new_layer.selectedFeatures() # Holen der aktuell ausgewählten Features
        
        if selected_features:
            count = len(selected_features)
            total_points = self.new_layer.featureCount()
            
            if count == total_points:
                QMessageBox.warning(None, "Fehler", "Operation nicht zulässig, Sie sind im Begriff, alle Punkte zu löschen.")
                return
                
            rp = QMessageBox.question(self, 'Bestätigung', 
                                     'Möchten Sie wirklich fortfahren und den Filtervorgang abschließen? Nachträgliche Änderungen sind nicht mehr möglich.', 
                                     QMessageBox.Yes | QMessageBox.No, 
                                     QMessageBox.No)
            
            if rp == QMessageBox.Yes:
                #### TODO: Filer-Protokoll erstellen
                # Fertig-Status setzen
                self.fertig = 1
                # Auswahltabelle zurücksetzen und Darstellung löschen
                self.auswahl_tabelle = None
                self.clear_table_widget_completely(self.tableWidget_Auswahl)
                # Filterparametertabelle zurücksetzen
                self.filterparameter_tabelle = None
                # Multiindex Dataframe für filterbasierte Punktauswahl zurücksetzen
                self.filter_punktauswahl = None
                # Lable zurücksetzen
                self.count_LB_label.setText("kein Filter angewand")
                self.count_UB_label.setText("kein Filter angewand")
                self.count_SD_label.setText("kein Filter angewand")
                # SpinBoxes zurücksetzen
                self.reset_spinboxes()
                # Filter-Tab sperren
                self.tabWidget.setTabEnabled(1, False)
                # Attribute-Tab freigeben
                self.tabWidget.setTabEnabled(2, True)
                # Auf Attribute-Tab wechseln
                self.tabWidget.setCurrentIndex(2)
                # Punkte löschen          
                self.new_layer.startEditing() # Bearbeitung des Layers starten
                for feature in selected_features: # Löschen der ausgewählten Features
                    self.new_layer.deleteFeature(feature.id())
                self.new_layer.commitChanges() # Änderungen speichern und Bearbeitung beenden
                self.on_SymbButton_clicked()
        else:
            rp = QMessageBox.question(self, 'Bestätigung', 
                                     'Es wurden keine Punkte durch die Filter ausgewählt. Wollen Sie dennoch fortfahren?', 
                                     QMessageBox.Yes | QMessageBox.No, 
                                     QMessageBox.No)
            if rp == QMessageBox.Yes:
                # Fertig-Status setzen
                self.fertig = 1
                # Auswahltabelle zurücksetzen und Darstellung löschen
                self.auswahl_tabelle = None
                self.clear_table_widget_completely(self.tableWidget_Auswahl)
                # Filterparametertabelle zurücksetzen
                self.filterparameter_tabelle = None
                # Multiindex Dataframe für filterbasierte Punktauswahl zurücksetzen
                self.filter_punktauswahl = None
                # Lable zurücksetzen
                self.count_LB_label.setText("kein Filter angewand")
                self.count_UB_label.setText("kein Filter angewand")
                self.count_SD_label.setText("kein Filter angewand")
                # SpinBoxes zurücksetzen
                self.reset_spinboxes()
                # Filter-Tab sperren
                self.tabWidget.setTabEnabled(1, False)
                # Attribute-Tab freigeben
                self.tabWidget.setTabEnabled(2, True)
                # Auf Attribute-Tab wechseln
                self.tabWidget.setCurrentIndex(2)
                # Änderungen speichern und Bearbeitung beenden
                self.new_layer.commitChanges() # Änderungen speichern und Bearbeitung beenden
                self.on_SymbButton_clicked()
                              
        self.parzellen_layer_check(False)
        
        
        
    def on_back_button_clicked(self):
        aw = QMessageBox.question(self, 'Bestätigung', 
                                     'Möchten Sie wirklich zurück gehen, die angewendeten Filter gehen verloren.', 
                                     QMessageBox.Yes | QMessageBox.No, 
                                     QMessageBox.No)
        
        if aw == QMessageBox.Yes:
            self.tabWidget.setTabEnabled(1, False)
            self.tabWidget.setCurrentIndex(0)
            self.tabWidget.setTabEnabled(0, True)
            
            # Auswahltabelle zurücksetzen und Darstellung löschen
            self.auswahl_tabelle = None
            self.clear_table_widget_completely(self.tableWidget_Auswahl)
            # Filterparametertabelle zurücksetzen
            self.filterparameter_tabelle = None
            # Multiindex Dataframe für filterbasierte Punktauswahl zurücksetzen
            self.filter_punktauswahl = None
            # Auswahl zurücksetzen
            self.new_layer.removeSelection()
            # Auswahl-Liste zurücksetzen
            self.punktauswahl_gesamt = None
            # Auswahl-Zähler zurücksetzen
            self.gesamtauswahl = None
            # Lable zurücksetzen
            self.count_LB_label.setText("kein Filter angewand")
            self.count_UB_label.setText("kein Filter angewand")
            self.count_SD_label.setText("kein Filter angewand")
            self.label_auswahl.setText("keine Filter angewand")
            self.label_auswahl_rel.setText("")
            self.reset_spinboxes()
            self.plugin_instance.punktauswahl_gesamt = []                    
            self.fill_map_widget_zuschneiden()
        
    ###############
    ### Abbruch ###
    ###############
    # Button "Abbrechen" im Reiter "Daten" und "Filter"
    def on_cancel_button_clicked(self):
        """closeEvent ausführen"""        
        self.close()  # Schließt das Fenster und ruft das 'closeEvent' auf
        
    # Button "Beenden" im Reiter "Attribute einfügen"
    def on_exit_button_clicked(self):
        rp = QMessageBox.question(None, "Plugin Beenden?", "Möchten Sie die Bearbeitung des Datensatzes wirklich beenden?",
                                  QMessageBox.Yes | QMessageBox.No)
        if rp == QMessageBox.Yes:
            self.close()
            # self.log.write_logs()
        
    def closeEvent(self, event):
        """Cleanup ausführen, wenn Fenster geschlossen wird"""        
        self.is_closing = True
        # Aktion bei Schließen des Fensters über das "X"
        
        if self.fertig == 0:
            reply = QMessageBox.question(self, 'Bestätigung', 
                                         'Möchten Sie das Plugin wirklich schließen?', 
                                         QMessageBox.Yes | QMessageBox.No, 
                                         QMessageBox.No)

            if reply == QMessageBox.Yes:
                if hasattr(self, 'new_layer') and self.new_layer is not None:
                    # Remove the layer from the QGIS project
                    QgsProject.instance().removeMapLayer(self.new_layer.id())
                    self.new_layer = None  # Clear the reference to the layer

                    # Refresh the map canvas
                    iface.mapCanvas().refresh()

                # Clear any remaining dialogs
                if hasattr(self, 'dialog'):
                    self.dialog.close()
                    del self.dialog

                # Call cleanup function from plugin instance
                if hasattr(self, 'plugin_instance'):
                    self.plugin_instance.cleanup_plugin_resources()

                # Reset UI components
                self.mMapLayerComboBox_Daten.setEnabled(True)
                self.mMapLayerComboBox_Parzellen.setEnabled(False)
                self.mMapLayerComboBox_Innenflaeche.setEnabled(False)
                self.mMapLayerComboBox_Feldgrenze.setEnabled(False)
                self.mMapLayerComboBox_AF.setEnabled(False)
                self.columnComboBox.setEnabled(False)        
                self.mMapLayerComboBox_Daten.setCurrentIndex(-1)
                self.mMapLayerComboBox_Parzellen.setCurrentIndex(-1)
                self.mMapLayerComboBox_Innenflaeche.setCurrentIndex(-1)
                self.mMapLayerComboBox_Feldgrenze.setCurrentIndex(-1)
                self.mMapLayerComboBox_AF.setCurrentIndex(-1)
                self.columnComboBox.clear()
                self.columnComboBox2.clear() # neu
                self.columnComboBox_Attribute.clear()
                self.cutFG.setEnabled(False)
                self.cutFB.setEnabled(False)
                self.cutPlot.setEnabled(False)
                self.cutPoints.setEnabled(False)
                self.cutAF.setEnabled(False)
                self.SymbButton.setEnabled(False)
                self.Attribut_label.setText("")
                self.clear_table_widget_completely(self.tableWidget_Auswahl)
                self.reset_spinboxes()
                self.tabWidget.setTabEnabled(1, False)
                self.tabWidget.setCurrentIndex(0)
                self.tabWidget.setTabEnabled(0, True)
                self.comboBox_LB.setCurrentIndex(0)
                self.comboBox_UB.setCurrentIndex(0)
                self.comboBox_sd.setCurrentIndex(0)
                self.count_LB_label.setText("kein Filter angewand")
                self.count_UB_label.setText("kein Filter angewand")
                self.count_SD_label.setText("kein Filter angewand")
                self.label_auswahl.setText("keine Filter angewand")
                self.label_auswahl_rel.setText("")
                self.tabWidget.setTabEnabled(2, False)
                self.pushButton.setEnabled(True)
                self.mComboBox_Plots.clear()
                self.mComboBox_Plots.setEnabled(False)
                
                # Entferne den Hintergrundlayer, falls er existiert
                try:
                    if hasattr(self, 'background_layer') and self.background_layer.isValid():
                        QgsProject.instance().removeMapLayer(self.background_layer.id())
                except RuntimeError:
                    print("Der Hintergrundlayer wurde bereits gelöscht oder ist ungültig.")

                # Leere die Layer vom MapCanvas und aktualisiere es
                self.mapCanvas.setLayers([])
                self.mapCanvas.refresh()
                
                # Histogramme zurücksetzen
                if hasattr(self, 'figure'):
                    self.figure.clear() # Löscht den Inhalt der Figur (die erstellten Histogramme)
                    self.histogram_canvas.draw() # Aktualisiert das Canvas, um die Löschung der Diagramme zu zeigen
                
                self.is_closing = False                
                event.accept()  # Fenster wird geschlossen
            
            else:
                event.ignore()  # Fenster bleibt geöffnet
        else:
            # Clear any remaining dialogs
                if hasattr(self, 'dialog'):
                    self.dialog.close()
                    del self.dialog

                # Call cleanup function from plugin instance
                if hasattr(self, 'plugin_instance'):
                    self.plugin_instance.cleanup_plugin_resources()

                # Reset UI components
                self.mMapLayerComboBox_Daten.setEnabled(True)
                self.mMapLayerComboBox_Parzellen.setEnabled(False)
                self.mMapLayerComboBox_Innenflaeche.setEnabled(False)
                self.mMapLayerComboBox_Feldgrenze.setEnabled(False)
                self.mMapLayerComboBox_AF.setEnabled(False)
                self.columnComboBox.setEnabled(False)        
                self.mMapLayerComboBox_Daten.setCurrentIndex(-1)
                self.mMapLayerComboBox_Parzellen.setCurrentIndex(-1)
                self.mMapLayerComboBox_Innenflaeche.setCurrentIndex(-1)
                self.mMapLayerComboBox_Feldgrenze.setCurrentIndex(-1)
                self.mMapLayerComboBox_AF.setCurrentIndex(-1)
                self.columnComboBox.clear()
                self.columnComboBox2.clear() # neu
                self.columnComboBox_Attribute.clear()
                self.cutFG.setEnabled(False)
                self.cutFB.setEnabled(False)
                self.cutPlot.setEnabled(False)
                self.cutPoints.setEnabled(False)
                self.cutAF.setEnabled(False)
                self.SymbButton.setEnabled(False)
                self.Attribut_label.setText("")
                self.clear_table_widget_completely(self.tableWidget_Auswahl)
                self.reset_spinboxes()
                self.tabWidget.setTabEnabled(1, False)
                self.tabWidget.setCurrentIndex(0)
                self.tabWidget.setTabEnabled(0, True)
                self.comboBox_LB.setCurrentIndex(0)
                self.comboBox_UB.setCurrentIndex(0)
                self.count_LB_label.setText("kein Filter angewand")
                self.count_UB_label.setText("kein Filter angewand")
                self.count_SD_label.setText("kein Filter angewand")
                self.label_auswahl.setText("keine Filter angewand")
                self.label_auswahl_rel.setText("")
                self.fertig = 0
                self.tabWidget.setTabEnabled(2, False)
                self.pushButton.setEnabled(True)
                
                # Histogramme zurücksetzen
                if hasattr(self, 'figure'):
                    self.figure.clear() # Löscht den Inhalt der Figur (die erstellten Histogramme)
                    self.histogram_canvas.draw() # Aktualisiert das Canvas, um die Löschung der Diagramme zu zeigen
                    
                # Entferne den Hintergrundlayer, falls er existiert
                try:
                    if hasattr(self, 'background_layer') and self.background_layer.isValid():
                        QgsProject.instance().removeMapLayer(self.background_layer.id())
                except RuntimeError:
                    print("Der Hintergrundlayer wurde bereits gelöscht oder ist ungültig.")

                # Leere die Layer vom MapCanvas und aktualisiere es
                self.mapCanvas.setLayers([])
                self.mapCanvas.refresh()
                
                iface.mapCanvas().refresh()
                    
                self.is_closing = False